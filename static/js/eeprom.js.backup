// static/js/eeprom.js
// EEPROM Hardware Integration for Genetic Circuit Designer

// ===== COMPONENT SELECTION CONSTANTS =====
const REGULATOR_TYPES = ['Repressor Start', 'Repressor End', 'Activator Start', 'Activator End', 
                        'Inducer Start', 'Inducer End', 'Inhibitor Start', 'Inhibitor End'];

// ===== APPLICATION STATE =====
const state = {
    currentComponent: null,
    currentGene: '1', // Default to Gene 1
    currentStrength: 'norm',
    placedComponents: [],
    componentCounts: {}, // For auto-numbering: promoter_1, promoter_2, etc.
    isDragging: false,
    draggedElement: null,
    // Cellboard format matching backend expectations
    cellboard: {
        'Promoter': [],
        'RBS': [],
        'CDS': [],
        'Terminator': [],
        'Repressor Start': [],
        'Repressor End': [],
        'Activator Start': [],
        'Activator End': [],
        'Inducer Start': [],
        'Inducer End': [],
        'Inhibitor Start': [],
        'Inhibitor End': []
    }
};

// ===== DOM INITIALIZATION =====
// Single DOMContentLoaded handler to prevent conflicts
let isInitialized = false;
document.addEventListener('DOMContentLoaded', function() {
    if (isInitialized) return;
    isInitialized = true;
    
    console.log('Initializing EEPROM board mode...');
    initHamburgerMenu();
    initComponentSystem();
});

function initHamburgerMenu() {
    const hamburgerToggle = document.getElementById('hamburger-toggle');
    const parametersPanel = document.getElementById('parameters-panel');
    const closePanel = document.getElementById('close-panel');
    
    if (!hamburgerToggle || !parametersPanel) {
        console.warn('Hamburger menu elements not found');
        return;
    }
    
    // Create backdrop element
    const backdrop = document.createElement('div');
    backdrop.className = 'panel-backdrop';
    document.body.appendChild(backdrop);
    
    // Simplified hamburger toggle functionality
    function togglePanel(e) {
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        
        const isOpen = parametersPanel.classList.contains('open');
        
        if (isOpen) {
            closeParametersPanel();
        } else {
            openParametersPanel();
        }
    }
    
    function openParametersPanel() {
        parametersPanel.classList.add('open');
        hamburgerToggle.classList.add('active');
        backdrop.classList.add('active');
        document.body.style.overflow = 'hidden';
    }
    
    function closeParametersPanel() {
        parametersPanel.classList.remove('open');
        hamburgerToggle.classList.remove('active');
        backdrop.classList.remove('active');
        document.body.style.overflow = '';
    }
    
    // Event listeners
    hamburgerToggle?.addEventListener('click', togglePanel);
    closePanel?.addEventListener('click', closeParametersPanel);
    backdrop.addEventListener('click', closeParametersPanel);
    
    // Close panel on Escape key
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && parametersPanel.classList.contains('open')) {
            closeParametersPanel();
        }
    });
    
    // Handle window resize
    window.addEventListener('resize', function() {
        if (window.innerWidth > 1024 && parametersPanel.classList.contains('open')) {
            // Auto-close on larger screens if needed
            // closeParametersPanel();
        }
    });
}

// ===== COMPONENT SELECTION SYSTEM =====
function initComponentSystem() {
    const components = document.querySelectorAll('.component');
    const cells = document.querySelectorAll('.cell');
    
    console.log(`Found ${components.length} components and ${cells.length} cells`);
    
    if (components.length === 0) {
        console.warn('No components found - retrying in 500ms');
        setTimeout(initComponentSystem, 500);
        return;
    }
    
    if (cells.length === 0) {
        console.warn('No cells found - retrying in 500ms');
        setTimeout(initComponentSystem, 500);
        return;
    }
    
    setupComponents();
    setupCells();
    setupGlobalClicks();
    updateSelectionStatus();
    
    // Ensure buttons are set up after component system is ready
    setTimeout(() => {
        const init = document.querySelector('.cell-board') ? true : false;
        if (init) {
            const setupButtonsFunc = window.setupButtons || setupButtons;
            if (typeof setupButtonsFunc === 'function') {
                setupButtonsFunc();
            }
        }
    }, 200);
    
    console.log('Component selection system initialized successfully');
}

// Setup global click handler to clear selection
function setupGlobalClicks() {
    document.addEventListener('click', function(e) {
        // Check if click is outside component palette and board
        const isComponentClick = e.target.closest('.component');
        const isBoardClick = e.target.closest('.cell-board');
        const isPaletteClick = e.target.closest('.component-palette');
        const isHamburgerClick = e.target.closest('.hamburger-menu') || e.target.closest('.parameters-panel');
        
        if (!isComponentClick && !isBoardClick && !isPaletteClick && !isHamburgerClick) {
            // Clear selection if clicking outside
            if (state.currentComponent) {
                clearComponentSelection();
                state.currentComponent = null;
                state.currentStrength = 'norm';
                updateSelectionStatus();
                console.log('Selection cleared');
            }
        }
    });
}

// Component selection and interaction
function setupComponents() {
    const components = document.querySelectorAll('.component');
    
    console.log(`Found ${components.length} components`);
    
    components.forEach(comp => {
        console.log(`Setting up component: ${comp.dataset.component}`);
        
        // Component click for selection
        comp.addEventListener('click', function(e) {
            e.stopPropagation();
            
            // Get the component element (in case we clicked on a child element)
            const componentElement = e.target.closest('.component');
            const componentType = componentElement ? componentElement.dataset.component : this.dataset.component;
            
            console.log(`Clicked component with data-component: ${componentType}`);
            console.log(`Event target:`, e.target);
            console.log(`This element:`, this);
            console.log(`Closest component:`, componentElement);
            
            // Clear previous selection
            clearComponentSelection();
            
            // Set current component
            state.currentComponent = componentType;
            state.currentStrength = 'norm'; // Default strength
            
            console.log(`State updated - currentComponent: ${state.currentComponent}`);
            
            // Add selected state to the correct component element
            (componentElement || this).classList.add('selected');
            
            // Show placement mode on board
            showPlacementMode();
            
            // Visual feedback
            this.style.transform = 'scale(0.95)';
            setTimeout(() => {
                this.style.transform = '';
            }, 150);
            
            // Update selection status
            updateSelectionStatus();
            
            console.log(`Selected component: ${state.currentComponent}`);
        });
    });
}

// Cell board interaction
function setupCells() {
    const cells = document.querySelectorAll('.cell');
    
    cells.forEach(cell => {
        // Click to place selected component
        cell.addEventListener('click', function(e) {
            console.log(`Cell clicked at (${this.dataset.x}, ${this.dataset.y})`);
            console.log(`Current selected component: ${state.currentComponent}`);
            
            if (state.currentComponent && state.currentComponent !== 'undefined') {
                const x = parseInt(this.dataset.x);
                const y = parseInt(this.dataset.y);
                
                console.log(`Placing component ${state.currentComponent} at (${x}, ${y})`);
                
                // Check if cell is already occupied
                if (this.classList.contains('has-component')) {
                    // Remove existing component first  
                    const existingIndex = state.placedComponents.findIndex(c => c.x == x && c.y == y);
                    if (existingIndex >= 0) {
                        state.placedComponents.splice(existingIndex, 1);
                    }
                    this.innerHTML = '';
                    this.classList.remove('has-component');
                }
                
                // Place the component using the updated logic
                const baseType = state.currentComponent.toLowerCase().replace(' ', '_');
                if (!state.componentCounts[baseType]) {
                    state.componentCounts[baseType] = 1;
                } else {
                    state.componentCounts[baseType]++;
                }
                
                const component = {
                    type: state.currentComponent,
                    number: state.componentCounts[baseType],
                    strength: state.currentStrength || 'norm',
                    x: x,
                    y: y,
                    id: Date.now() + Math.random(),
                    customName: null,
                    parameters: {}
                };
                
                state.placedComponents.push(component);
                console.log('Component placed:', component);
                
                // Update visual
                updateCellDisplay(x, y, component.type, component.number, component.customName);
                
                // Clear selection after placing
                clearComponentSelection();
                state.currentComponent = null;
                state.currentStrength = 'norm';
                updateSelectionStatus();
            } else {
                console.log('No component selected');
                // No component selected - show message
                showSelectionHint();
            }
        });
        
        // Right-click to remove component
        cell.addEventListener('contextmenu', function(e) {
            e.preventDefault();
            const x = parseInt(this.dataset.x);
            const y = parseInt(this.dataset.y);
            removeComponent(x, y);
        });
    });
}

// Component placement logic
function placeComponent(x, y, componentType, strength = 'norm') {
    console.log(`placeComponent called with: componentType=${componentType}, x=${x}, y=${y}`);
    
    // Check for undefined component type
    if (!componentType) {
        console.error('Cannot place component: componentType is undefined');
        return null;
    }
    
    // Auto-increment component number based on type
    const baseType = componentType.toLowerCase().replace(' ', '_');
    if (!state.componentCounts[baseType]) {
        state.componentCounts[baseType] = 1;
    } else {
        state.componentCounts[baseType]++;
    }

    const component = {
        x: x,
        y: y,
        type: componentType,
        strength: strength,
        id: Date.now() + Math.random(), // Unique ID
        number: state.componentCounts[baseType] // For display
    };
    
    // Add to cellboard in backend-compatible format
    if (!state.cellboard[componentType]) {
        state.cellboard[componentType] = [];
    }
    state.cellboard[componentType].push(component);
    
    // Update visual representation
    updateCellDisplay(x, y, componentType, state.componentCounts[baseType]);
    
    // Create dynamic parameter section if needed
    createDynamicParameterSection(componentType, state.componentCounts[baseType]);
    
    console.log(`Placed ${componentType} #${state.componentCounts[baseType]} at (${x}, ${y})`);
    return component;
}

// Remove component from position
function removeComponent(x, y) {
    console.log(`Attempting to remove component at (${x}, ${y})`);
    
    // Find and remove component from placedComponents array
    const index = state.placedComponents.findIndex(comp => comp.x === x && comp.y === y);
    let removed = null;
    
    if (index !== -1) {
        removed = state.placedComponents.splice(index, 1)[0];
        console.log(`Found component in placedComponents:`, removed);
    }
    
    // Also remove from cellboard if it exists there
    if (!removed) {
        for (const [type, components] of Object.entries(state.cellboard)) {
            const cellboardIndex = components.findIndex(comp => comp.x === x && comp.y === y);
            if (cellboardIndex !== -1) {
                removed = components.splice(cellboardIndex, 1)[0];
                console.log(`Found component in cellboard:`, removed);
                break;
            }
        }
    }
    
    if (removed) {
        // Clear visual representation
        const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        if (cell) {
            cell.innerHTML = '';
            cell.classList.remove('filled');
            cell.classList.remove('has-component');
            console.log(`Cleared visual at (${x}, ${y})`);
        }
        
        // Remove dynamic parameter section if it exists
        if (removed.number) {
            removeDynamicParameterSection(removed.type, removed.number);
        }
        
        console.log(`Successfully removed ${removed.type} from (${x}, ${y})`);
    } else {
        console.log(`No component found at (${x}, ${y})`);
    }
    
    return removed;
}

// Update cell display
function updateCellDisplay(x, y, componentType, componentNumber, customName = null) {
    console.log(`updateCellDisplay called with: x=${x}, y=${y}, componentType=${componentType}, componentNumber=${componentNumber}`);
    
    const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
    if (!cell) {
        console.error(`Cell not found at (${x}, ${y})`);
        return;
    }
    
    // Clear previous content
    cell.innerHTML = '';
    cell.classList.add('filled');
    
    // Find the component in our data to get its custom name
    let component = null;
    for (const [type, components] of Object.entries(state.cellboard)) {
        component = components.find(comp => comp.x === x && comp.y === y);
        if (component) break;
    }
    
    // Create component display
    const display = document.createElement('div');
    display.className = 'placed-component';
    
    // Use custom name if available, otherwise show full component type
    const displayName = (component && component.customName) || componentType || 'Unknown Component';
    console.log(`Display name will be: ${displayName} (componentType: ${componentType})`);
    display.textContent = displayName;
    display.title = `${componentType} #${componentNumber} - Click to edit parameters`;
    
    // Add component-specific styling
    display.classList.add(`component-${componentType.toLowerCase().replace(' ', '-')}`);
    
    // Add click event for parameter editing (exclude regulators)
    if (!REGULATOR_TYPES.includes(componentType)) {
        display.addEventListener('click', function(e) {
            e.stopPropagation();
            showComponentParameterModal(x, y, componentType, componentNumber, component);
        });
        
        // Add visual indicator that component is clickable for parameters
        display.classList.add('has-parameters');
        display.title += ' (Click to edit parameters & rename)';
    }
    
    cell.appendChild(display);
}

// Selection status and visual feedback functions
function clearComponentSelection() {
    // Remove selected class from all components
    document.querySelectorAll('.component.selected').forEach(comp => {
        comp.classList.remove('selected');
    });
    
    // Hide placement mode
    hidePlacementMode();
}

function showPlacementMode() {
    // Add placement mode class to board
    const board = document.querySelector('.cell-board');
    if (board) {
        board.classList.add('placement-mode');
    }
    
    // Add hover effects to empty cells
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        if (!cell.classList.contains('filled')) {
            cell.classList.add('placement-ready');
        }
    });
}

function hidePlacementMode() {
    // Remove placement mode class from board
    const board = document.querySelector('.cell-board');
    if (board) {
        board.classList.remove('placement-mode');
    }
    
    // Remove hover effects from cells
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        cell.classList.remove('placement-ready');
    });
}

function showSelectionHint() {
    // Show a brief hint that user needs to select a component first
    const hint = document.createElement('div');
    hint.className = 'selection-hint';
    hint.textContent = 'Select a component first!';
    hint.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(231, 76, 60, 0.9);
        color: white;
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        font-weight: bold;
        animation: fadeInOut 2s ease-in-out;
    `;
    
    document.body.appendChild(hint);
    
    // Remove hint after animation
    setTimeout(() => {
        if (hint.parentNode) {
            hint.parentNode.removeChild(hint);
        }
    }, 2000);
}

function updateSelectionStatus() {
    const statusElement = document.getElementById('selection-status');
    if (!statusElement) return;
    
    const icon = statusElement.querySelector('i');
    const text = statusElement.querySelector('span');
    
    if (state.currentComponent) {
        icon.className = 'fas fa-check-circle';
        text.textContent = `Selected: ${state.currentComponent}`;
        statusElement.className = 'selection-status selected';
    } else {
        icon.className = 'fas fa-mouse-pointer';
        text.textContent = 'Click a component to select';
        statusElement.className = 'selection-status';
    }
}

// ===== DYNAMIC PARAMETER SECTION CREATION =====
// Dynamic parameter section creation
function createDynamicParameterSection(componentType, componentNumber) {
    const dialAccordion = document.querySelector('.dial-accordion');
    if (!dialAccordion) return;
    
    // Skip parameter sections for regulator components (they use constants from constants.py)
    if (REGULATOR_TYPES.includes(componentType)) {
        console.log(`Skipping parameter section for regulator component: ${componentType}`);
        return;
    }
    
    // Create unique ID for this component instance
    const baseType = componentType.toLowerCase().replace(' ', '_');
    const sectionId = `${baseType}_${componentNumber}`;
    
    // Check if section already exists
    if (document.getElementById(`section_${sectionId}`)) {
        return; // Already exists
    }
    
    // Create the parameter section
    const section = document.createElement('details');
    section.className = 'dial-accordion-item';
    section.id = `section_${sectionId}`;
    
    const summary = document.createElement('summary');
    summary.className = 'dial-accordion-header';
    summary.textContent = `${componentType} ${componentNumber} Parameters`;
    
    const body = document.createElement('div');
    body.className = 'dial-accordion-body';
    
    const grid = document.createElement('div');
    grid.className = 'dial-grid';
    
    // Generate parameters based on component type
    const parameters = getComponentParameters(componentType, componentNumber);
    
    parameters.forEach(param => {
        const label = document.createElement('label');
        label.setAttribute('for', param.id);
        label.textContent = param.label;
        
        const input = document.createElement('input');
        input.type = 'number';
        input.id = param.id;
        input.name = param.id;
        input.min = param.min;
        input.max = param.max;
        input.step = param.step;
        input.value = param.defaultValue;
        
        if (param.title) {
            input.title = param.title;
        }
        
        grid.appendChild(label);
        grid.appendChild(input);
    });
    
    body.appendChild(grid);
    section.appendChild(summary);
    section.appendChild(body);
    
    // Insert before the last section (or at the end)
    dialAccordion.appendChild(section);
    
    console.log(`Created parameter section for ${componentType} ${componentNumber}`);
}

// Remove dynamic parameter section
function removeDynamicParameterSection(componentType, componentNumber) {
    const baseType = componentType.toLowerCase().replace(' ', '_');
    const sectionId = `${baseType}_${componentNumber}`;
    const section = document.getElementById(`section_${sectionId}`);
    
    if (section) {
        section.remove();
        console.log(`Removed parameter section for ${componentType} ${componentNumber}`);
    }
}

// ===== COMPONENT PARAMETER SYSTEM =====
// Get parameters for a specific component type
function getComponentParameters(componentType, componentNumber) {
    // Skip parameters for regulator components
    if (REGULATOR_TYPES.includes(componentType)) {
        return [];
    }
    
    const baseType = componentType.toLowerCase().replace(' ', '_');
    const num = componentNumber;
    
    const commonParams = {
        'Promoter': [
            {
                id: `promoter${num}_strength`,
                label: 'Promoter Strength:',
                min: 0.1,
                max: 5.0,
                step: 0.1,
                defaultValue: 1.0
            }
        ],
        'RBS': [
            {
                id: `rbs${num}_efficiency`,
                label: 'RBS Efficiency:',
                min: 0.1,
                max: 2.0,
                step: 0.1,
                defaultValue: 1.0
            }
        ],
        'CDS': [
            {
                id: `cds${num}_translation_rate`,
                label: 'CDS Translation Rate:',
                min: 1.0,
                max: 20.0,
                step: 0.5,
                defaultValue: 5.0
            },
            {
                id: `cds${num}_degradation_rate`,
                label: 'CDS Degradation Rate:',
                min: 0.01,
                max: 1.0,
                step: 0.01,
                defaultValue: 0.1
            },
            {
                id: `protein${num}_initial_conc`,
                label: 'Initial Protein Conc:',
                min: 0.0,
                max: 2.0,
                step: 0.05,
                defaultValue: 0.1,
                title: 'Starting concentration (µM) - affects oscillation dynamics'
            }
        ],
        'Terminator': [
            {
                id: `terminator${num}_efficiency`,
                label: 'Terminator Efficiency:',
                min: 0.1,
                max: 1.0,
                step: 0.01,
                defaultValue: 0.99
            }
        ]
    };
    
    return commonParams[componentType] || [];
}

// Show component parameter modal
function showComponentParameterModal(x, y, componentType, componentNumber, component) {
    // Create modal overlay
    const overlay = document.createElement('div');
    overlay.className = 'parameter-modal-overlay';
    
    // Create modal content
    const modal = document.createElement('div');
    modal.className = 'parameter-modal';
    
    // Modal header
    const header = document.createElement('div');
    header.className = 'parameter-modal-header';
    
    const title = document.createElement('h3');
    title.textContent = `${component?.customName || componentType + ' #' + componentNumber} Parameters`;
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'parameter-modal-close';
    closeBtn.innerHTML = '×';
    closeBtn.onclick = () => overlay.remove();
    
    header.appendChild(title);
    header.appendChild(closeBtn);
    
    // Modal body with parameters
    const body = document.createElement('div');
    body.className = 'parameter-modal-body';
    
    // Add component name/rename field first
    const nameGroup = document.createElement('div');
    nameGroup.className = 'parameter-group name-group';
    
    const nameLabel = document.createElement('label');
    nameLabel.textContent = 'Component Name:';
    nameLabel.setAttribute('for', 'component-name-input');
    
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.id = 'component-name-input';
    nameInput.placeholder = `${componentType} #${componentNumber}`;
    nameInput.value = component?.customName || '';
    
    // Add real-time name update
    nameInput.addEventListener('input', function() {
        if (component) {
            component.customName = this.value.trim() || null;
            // Update the modal title in real-time
            title.textContent = `${this.value.trim() || componentType + ' #' + componentNumber} Parameters`;
            console.log(`Renamed component to: ${this.value.trim()}`);
        }
    });
    
    nameGroup.appendChild(nameLabel);
    nameGroup.appendChild(nameInput);
    body.appendChild(nameGroup);
    
    // Add separator
    const separator = document.createElement('div');
    separator.className = 'parameter-separator';
    separator.innerHTML = '<hr style="border-color: rgba(255,255,255,0.1); margin: 15px 0;">';
    body.appendChild(separator);
    
    // Get parameters for this component
    const parameters = getComponentParameters(componentType, componentNumber);
    
    parameters.forEach(param => {
        const paramGroup = document.createElement('div');
        paramGroup.className = 'parameter-group';
        
        const label = document.createElement('label');
        label.textContent = param.label;
        label.setAttribute('for', param.id);
        
        const input = document.createElement('input');
        input.type = 'number';
        input.id = param.id;
        input.name = param.id;
        input.min = param.min;
        input.max = param.max;
        input.step = param.step;
        // Load existing value if available, otherwise use default
        const existingValue = component?.parameters?.[param.id];
        input.value = existingValue !== undefined ? existingValue : param.defaultValue;
        
        if (param.title) {
            input.title = param.title;
        }
        
        // Add real-time update
        input.addEventListener('input', function() {
            // Update component data
            if (component) {
                if (!component.parameters) component.parameters = {};
                component.parameters[param.id] = parseFloat(this.value);
            }
            console.log(`Updated ${param.id} to ${this.value} for component at (${x}, ${y})`);
        });
        
        paramGroup.appendChild(label);
        paramGroup.appendChild(input);
        body.appendChild(paramGroup);
    });
    
    // Modal footer
    const footer = document.createElement('div');
    footer.className = 'parameter-modal-footer';
    
    const applyBtn = document.createElement('button');
    applyBtn.className = 'btn btn-primary';
    applyBtn.textContent = 'Apply';
    applyBtn.onclick = () => {
        // Parameters and name are already updated in real-time
        // Update the visual display to reflect any name changes
        updateCellDisplay(x, y, componentType, componentNumber, component?.customName);
        overlay.remove();
        console.log(`Applied parameters and name for ${componentType} at (${x}, ${y})`);
    };
    
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'btn btn-secondary';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.onclick = () => overlay.remove();
    
    footer.appendChild(cancelBtn);
    footer.appendChild(applyBtn);
    
    // Assemble modal
    modal.appendChild(header);
    modal.appendChild(body);
    modal.appendChild(footer);
    overlay.appendChild(modal);
    
    // Add to page
    document.body.appendChild(overlay);
    
    // Close on overlay click
    overlay.addEventListener('click', function(e) {
        if (e.target === overlay) {
            overlay.remove();
        }
    });
}

// ===== EEPROM HARDWARE INTEGRATION =====

let LOG_LINES = [];
let port = null;
let reader = null;
let writer = null;
let textDecoder = null;
let textEncoder = null;
let readableStreamClosed = null;
let writableStreamClosed = null;
let isConnecting = false;  // Prevent concurrent operations
let lineBuffer = '';  // Buffer for partial lines to prevent hex data corruption

// DOM elements
const comPortSelect = document.getElementById("com-port");
const btnRefreshPorts = document.getElementById("btn-refresh-ports");
const btnConnect = document.getElementById("btn-connect");
const btnGetBoard = document.getElementById("btn-get-board");
const btnDiagnoseBoard = document.getElementById("btn-diagnose-board");
const eepromLogArea = document.getElementById("eeprom-log");
const errorDisplay = document.getElementById("error-display");
const plotContainer = document.getElementById("plot-container");

// Initialize EEPROM interface - DISABLED to prevent conflicts
// document.addEventListener('DOMContentLoaded', function() {
//     init();
// });

async function init() {
    // Check for Web Serial API support
    if (!('serial' in navigator)) {
        logLine('Web Serial API not supported. Please use Chrome 89+ or Edge 89+');
        logLine('Note: Some browsers require flags to be enabled');
        btnConnect.disabled = true;
        btnRefreshPorts.disabled = true;
        return;
    }
    
    // Check if permissions are available
    try {
        await navigator.permissions.query({ name: 'serial' });
    } catch (err) {
        logLine('⚠️ Serial permissions may be restricted by browser policy');
        logLine('This might be due to iframe context, mixed content, or security settings');
        logLine('Try: 1) Opening in a new tab, 2) Using HTTPS, 3) Checking browser flags');
    }

    // Setup event listeners
    setupEventListeners();
    
    // Try to list previously granted ports
    listPorts();
}

function setupEventListeners() {
    if (btnRefreshPorts) {
        btnRefreshPorts.addEventListener("click", requestAndListPorts);
    }

    if (btnConnect) {
        btnConnect.addEventListener("click", connectToPort);
    }

    if (btnGetBoard) {
        btnGetBoard.addEventListener("click", readBoardConfiguration);
    }
    
    if (btnDiagnoseBoard) {
        btnDiagnoseBoard.addEventListener("click", diagnoseBoardEEPROMs);
    }
}

// ============================
// CONNECTOR SYSTEM CLASSES (EEPROM)
// ============================

// Genetic Circuit Connector - adapted from sample.js for EEPROM interface
class GeneticConnectorEEPROM {
    constructor() {
        this.id = `connector_${++ConnectorManagerEEPROM.nextUid}`;
        this.dragType = "connector";
        this.isSelected = false;
        this.element = ConnectorManagerEEPROM.connectorTemplate.cloneNode(true);
        this.path = this.element.querySelector(".connector-path");
        this.pathOutline = this.element.querySelector(".connector-path-outline");
        this.inputHandle = this.element.querySelector(".input-handle");
        this.outputHandle = this.element.querySelector(".output-handle");
        this.inputPort = null;
        this.outputPort = null;
        this.staticPort = null;
        this.dragElement = null;
        this.staticElement = null;
        this.isInput = false;
    }

    init(port) {
        ConnectorManagerEEPROM.connectionsLayer.appendChild(this.element);
        this.element.style.display = 'block';

        this.isInput = port.isInput;
        this.staticPort = port;

        if (port.isInput) {
            this.inputPort = port;
            this.dragElement = this.outputHandle;
            this.staticElement = this.inputHandle;
        } else {
            this.outputPort = port;
            this.dragElement = this.inputHandle;
            this.staticElement = this.outputHandle;
        }

        this.staticElement.setAttribute("data-drag", `${port.id}:port`);
        this.dragElement.setAttribute("data-drag", `${this.id}:connector`);

        // Set initial positions
        const pos = port.getGlobalPosition();
        this.inputHandle.setAttribute('cx', pos.x);
        this.inputHandle.setAttribute('cy', pos.y);
        this.outputHandle.setAttribute('cx', pos.x);
        this.outputHandle.setAttribute('cy', pos.y);

        this.updatePath();
    }

    updatePath() {
        const x1 = parseFloat(this.inputHandle.getAttribute('cx'));
        const y1 = parseFloat(this.inputHandle.getAttribute('cy'));
        const x4 = parseFloat(this.outputHandle.getAttribute('cx'));
        const y4 = parseFloat(this.outputHandle.getAttribute('cy'));

        const dx = Math.abs(x1 - x4) * 0.4; // bezier weight
        
        const p1x = x1, p1y = y1;
        const p2x = x1 - dx, p2y = y1;
        const p4x = x4, p4y = y4;
        const p3x = x4 + dx, p3y = y4;

        const pathData = `M${p1x} ${p1y} C ${p2x} ${p2y} ${p3x} ${p3y} ${p4x} ${p4y}`;
        this.path.setAttribute("d", pathData);
        this.pathOutline.setAttribute("d", pathData);
    }

    updateHandle(port) {
        const pos = port.getGlobalPosition();
        
        if (port === this.inputPort) {
            this.inputHandle.setAttribute('cx', pos.x);
            this.inputHandle.setAttribute('cy', pos.y);
        } else if (port === this.outputPort) {
            this.outputHandle.setAttribute('cx', pos.x);
            this.outputHandle.setAttribute('cy', pos.y);
        }

        this.updatePath();
    }

    placeHandle() {
        const dragPos = {
            x: parseFloat(this.dragElement.getAttribute('cx')),
            y: parseFloat(this.dragElement.getAttribute('cy'))
        };

        let targetPort = null;
        const targetComponents = ConnectorManagerEEPROM.getComponentsAtPosition(dragPos);

        for (let comp of targetComponents) {
            if (comp === this.staticPort.component) continue; // Skip same component
            
            const compatiblePorts = this.isInput ? comp.outputPorts : comp.inputPorts;
            for (let port of compatiblePorts) {
                if (this.isValidConnection(port)) {
                    const portPos = port.getGlobalPosition();
                    const distance = Math.sqrt(
                        Math.pow(dragPos.x - portPos.x, 2) + 
                        Math.pow(dragPos.y - portPos.y, 2)
                    );
                    
                    if (distance < 20) { // 20px snap distance
                        targetPort = port;
                        break;
                    }
                }
            }
            if (targetPort) break;
        }

        if (targetPort) {
            this.connectToPort(targetPort);
        } else {
            this.remove();
        }
    }

    connectToPort(port) {
        if (this.isInput) {
            this.outputPort = port;
        } else {
            this.inputPort = port;
        }

        this.dragElement.setAttribute("data-drag", `${port.id}:port`);
        port.addConnector(this);
        this.updateHandle(port);

        // Check compatibility and validate connection
        if (this.inputPort && this.outputPort) {
            if (!this.isValidConnection(port)) {
                this.remove();
                return;
            }
            
            console.log(`Connected ${this.outputPort.component.type} to ${this.inputPort.component.type}`);
        }
    }

    isValidConnection(targetPort) {
        if (!this.staticPort || !targetPort) return false;
        
        const sourceComp = this.staticPort.component;
        const targetComp = targetPort.component;
        
        // Prevent self-connection
        if (sourceComp === targetComp) return false;
        
        // Check if connecting input to output or vice versa
        if (this.isInput === targetPort.isInput) return false;
        
        // Check component type compatibility
        const sourceType = sourceComp.type;
        const targetType = targetComp.type;
        
        // Repressor Start can only connect to Repressor End
        if (sourceType === 'Repressor Start' && targetType !== 'Repressor End') return false;
        if (sourceType === 'Repressor End' && targetType !== 'Repressor Start') return false;
        
        // Activator Start can only connect to Activator End
        if (sourceType === 'Activator Start' && targetType !== 'Activator End') return false;
        if (sourceType === 'Activator End' && targetType !== 'Activator Start') return false;
        
        return true;
    }

    remove() {
        if (this.inputPort) {
            this.inputPort.removeConnector(this);
        }
        if (this.outputPort) {
            this.outputPort.removeConnector(this);
        }

        this.isSelected = false;
        this.path.removeAttribute("d");
        this.pathOutline.removeAttribute("d");
        this.dragElement.removeAttribute("data-drag");
        this.staticElement.removeAttribute("data-drag");

        this.staticPort = null;
        this.inputPort = null;
        this.outputPort = null;
        this.dragElement = null;
        this.staticElement = null;

        if (this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
        
        ConnectorManagerEEPROM.connectorPool.push(this);
    }

    onDrag() {
        this.updatePath();
    }

    onDragEnd() {
        this.placeHandle();
    }
}

// Component Port - represents connection points on genetic components (EEPROM version)
class ComponentPortEEPROM {
    constructor(component, isInput, element) {
        this.id = `port_${++ConnectorManagerEEPROM.nextUid}`;
        this.dragType = "port";
        this.component = component;
        this.isInput = isInput;
        this.element = element;
        this.connectors = [];
        this.lastConnector = null;

        // Add data attributes
        this.element.setAttribute("data-drag", `${this.id}:port`);
        this.element.classList.add(isInput ? 'input-port' : 'output-port');
    }

    createConnector() {
        let connector;
        
        if (ConnectorManagerEEPROM.connectorPool.length > 0) {
            connector = ConnectorManagerEEPROM.connectorPool.pop();
            ConnectorManagerEEPROM.connectorLookup[connector.id] = connector;
        } else {
            connector = new GeneticConnectorEEPROM();
            ConnectorManagerEEPROM.connectorLookup[connector.id] = connector;
        }

        connector.init(this);
        this.lastConnector = connector;
        this.connectors.push(connector);
        
        return connector;
    }

    addConnector(connector) {
        if (!this.connectors.includes(connector)) {
            this.connectors.push(connector);
            this.element.classList.add('connected');
        }
    }

    removeConnector(connector) {
        const index = this.connectors.indexOf(connector);
        if (index > -1) {
            this.connectors.splice(index, 1);
            if (this.connectors.length === 0) {
                this.element.classList.remove('connected');
            }
        }
    }

    getGlobalPosition() {
        const rect = this.element.getBoundingClientRect();
        const svgRect = document.getElementById('connector-svg').getBoundingClientRect();
        
        return {
            x: rect.left + rect.width/2 - svgRect.left,
            y: rect.top + rect.height/2 - svgRect.top
        };
    }

    update() {
        for (let connector of this.connectors) {
            connector.updateHandle(this);
        }
    }
}

// Genetic Component - wrapper for placed components with ports (EEPROM version)
class GeneticComponentEEPROM {
    constructor(placedComponent, cell) {
        this.id = `component_${++ConnectorManagerEEPROM.nextUid}`;
        this.type = placedComponent.type;
        this.gene = placedComponent.gene;
        this.strength = placedComponent.strength;
        this.cell = cell;
        this.element = cell;
        this.inputPorts = [];
        this.outputPorts = [];
        
        this.createPorts();
    }

    createPorts() {
        // Only regulatory components get ports
        console.log(`EEPROM: Creating ports for component: ${this.type}`);
        if (this.type === 'Repressor Start' || this.type === 'Activator Start') {
            console.log('EEPROM: Creating output port');
            this.createOutputPort();
        } else if (this.type === 'Repressor End' || this.type === 'Activator End') {
            console.log('EEPROM: Creating input port');
            this.createInputPort();
        }
    }

    createOutputPort() {
        const portElement = document.createElement('div');
        portElement.className = 'component-port output-port';
        portElement.title = 'Output Port - Click and drag to connect';
        this.element.appendChild(portElement);
        
        const port = new ComponentPortEEPROM(this, false, portElement);
        this.outputPorts.push(port);
        ConnectorManagerEEPROM.portLookup[port.id] = port;
        
        console.log('EEPROM: Output port created and added to cell:', portElement);
        return port;
    }

    createInputPort() {
        const portElement = document.createElement('div');
        portElement.className = 'component-port input-port';
        portElement.title = 'Input Port - Click and drag to connect';
        this.element.appendChild(portElement);
        
        const port = new ComponentPortEEPROM(this, true, portElement);
        this.inputPorts.push(port);
        ConnectorManagerEEPROM.portLookup[port.id] = port;
        
        console.log('EEPROM: Input port created and added to cell:', portElement);
        return port;
    }

    updatePorts() {
        [...this.inputPorts, ...this.outputPorts].forEach(port => port.update());
    }

    remove() {
        // Remove all connectors
        [...this.inputPorts, ...this.outputPorts].forEach(port => {
            [...port.connectors].forEach(connector => connector.remove());
        });

        // Remove port elements
        [...this.inputPorts, ...this.outputPorts].forEach(port => {
            if (port.element.parentNode) {
                port.element.parentNode.removeChild(port.element);
            }
            delete ConnectorManagerEEPROM.portLookup[port.id];
        });

        // Clear arrays
        this.inputPorts = [];
        this.outputPorts = [];
        
        delete ConnectorManagerEEPROM.componentLookup[this.id];
    }
}

// Connector Manager - orchestrates the entire connector system (EEPROM version)
class ConnectorManagerEEPROM {
    static nextUid = 0;
    static container = null;
    static connectionsLayer = null;
    static connectorTemplate = null;
    static componentLookup = {};
    static portLookup = {};
    static connectorLookup = {};
    static connectorPool = [];
    static isDragging = false;
    static dragTarget = null;

    static init() {
        this.container = document.querySelector('.grid-container');
        this.connectionsLayer = document.getElementById('connections-layer');
        this.connectorTemplate = document.querySelector('.connector-template');

        if (!this.container || !this.connectionsLayer || !this.connectorTemplate) {
            console.error('ConnectorManagerEEPROM: Required elements not found');
            return false;
        }

        this.setupDragHandling();
        return true;
    }

    static setupDragHandling() {
        let mousePos = { x: 0, y: 0 };

        this.container.addEventListener('mousedown', (e) => {
            const target = e.target;
            const dragData = target.getAttribute('data-drag');
            
            if (!dragData) return;
            
            const [id, type] = dragData.split(':');
            
            if (type === 'port') {
                e.preventDefault();
                const port = this.portLookup[id];
                if (port) {
                    this.startConnectorDrag(port, e);
                }
            } else if (type === 'connector') {
                e.preventDefault();
                const connector = this.connectorLookup[id];
                if (connector) {
                    this.startConnectorHandleDrag(connector, e);
                }
            }
        });

        this.container.addEventListener('mousemove', (e) => {
            mousePos.x = e.clientX;
            mousePos.y = e.clientY;
            
            if (this.isDragging && this.dragTarget) {
                const svgRect = document.getElementById('connector-svg').getBoundingClientRect();
                const x = e.clientX - svgRect.left;
                const y = e.clientY - svgRect.top;
                
                if (this.dragTarget.dragElement) {
                    this.dragTarget.dragElement.setAttribute('cx', x);
                    this.dragTarget.dragElement.setAttribute('cy', y);
                    this.dragTarget.onDrag();
                }
            }
        });

        this.container.addEventListener('mouseup', (e) => {
            if (this.isDragging && this.dragTarget) {
                this.dragTarget.onDragEnd();
                this.isDragging = false;
                this.dragTarget = null;
            }
        });
    }

    static startConnectorDrag(port, event) {
        const connector = port.createConnector();
        this.isDragging = true;
        this.dragTarget = connector;
        
        // Trigger initial mouse move to set position
        const svgRect = document.getElementById('connector-svg').getBoundingClientRect();
        const x = event.clientX - svgRect.left;
        const y = event.clientY - svgRect.top;
        
        connector.dragElement.setAttribute('cx', x);
        connector.dragElement.setAttribute('cy', y);
        connector.onDrag();
    }

    static startConnectorHandleDrag(connector, event) {
        this.isDragging = true;
        this.dragTarget = connector;
    }

    static addComponent(placedComponent, cell) {
        const component = new GeneticComponentEEPROM(placedComponent, cell);
        this.componentLookup[component.id] = component;
        return component;
    }

    static removeComponent(cell) {
        // Find component by cell
        const component = Object.values(this.componentLookup).find(comp => comp.cell === cell);
        if (component) {
            component.remove();
        }
    }

    static getComponentsAtPosition(pos) {
        return Object.values(this.componentLookup).filter(comp => {
            const rect = comp.element.getBoundingClientRect();
            const svgRect = document.getElementById('connector-svg').getBoundingClientRect();
            const compX = rect.left - svgRect.left;
            const compY = rect.top - svgRect.top;
            
            return pos.x >= compX && pos.x <= compX + rect.width &&
                   pos.y >= compY && pos.y <= compY + rect.height;
        });
    }

    static clearAll() {
        // Remove all connectors
        Object.values(this.connectorLookup).forEach(connector => connector.remove());
        
        // Remove all components
        Object.values(this.componentLookup).forEach(component => component.remove());
        
        // Clear lookups
        this.componentLookup = {};
        this.portLookup = {};
        this.connectorLookup = {};
        this.connectorPool = [];
    }
}

// List available COM ports
async function listPorts() {
    if (!comPortSelect) return;
    
    comPortSelect.innerHTML = '<option value="">Select COM Port</option>';
    
    try {
        const ports = await navigator.serial.getPorts();
        
        for (let i = 0; i < ports.length; i++) {
            const port = ports[i];
            const option = document.createElement("option");
            option.value = i;
            option.port = port;
            
            const info = port.getInfo();
            option.textContent = info.usbProductId 
                ? `USB Device ${info.usbVendorId}:${info.usbProductId}`
                : info.usbVendorId 
                ? `USB Device ${info.usbVendorId}`
                : `Serial Port ${i + 1}`;
                
            comPortSelect.appendChild(option);
        }

        if (ports.length === 0) {
            logLine('No previously granted ports found. Click "Refresh Ports" to request access.');
        } else {
            logLine(`Found ${ports.length} previously granted port(s).`);
        }
        
    } catch (err) {
        console.error("Error listing ports:", err);
        logLine(`Error listing ports: ${err.message}`);
    }
}

// Request new port and refresh list
async function requestAndListPorts() {
    try {
        // Request a new port
        await navigator.serial.requestPort();
        logLine('New port access granted.');
        
        // Refresh the list
        await listPorts();
        
    } catch (err) {
        // User cancelled the dialog
        console.log("Port request cancelled:", err);
        logLine('Port selection cancelled.');
    }
}

// Connect to selected COM port
async function connectToPort() {
    // Prevent concurrent operations
    if (isConnecting) {
        logLine('Connection already in progress...');
        return;
    }
    
    if (port) {
        logLine('Already connected to a port. Disconnecting first...');
        await disconnectPort();
    }
    
    isConnecting = true;

    let selectedPort = null;

    if (!comPortSelect.options.length || comPortSelect.selectedIndex === 0) {
        // No port selected, request one
        try {
            logLine('Requesting port access...');
            selectedPort = await navigator.serial.requestPort();
            logLine('Port selected via dialog.');
            
            // Add the new port to the dropdown
            await listPorts();
            
        } catch (err) {
            console.error("No port selected:", err);
            logLine('Port selection cancelled or failed.');
            isConnecting = false;  // CRITICAL FIX: Reset connection flag
            return;
        }
    } else {
        // Use selected port
        const selectedOption = comPortSelect.options[comPortSelect.selectedIndex];
        selectedPort = selectedOption.port;
        logLine(`Attempting to connect to selected port...`);
    }

    try {
        // Check if port is already open
        if (selectedPort.readable) {
            logLine('Port appears to be already open. Closing first...');
            await selectedPort.close();
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        // Open the port with appropriate settings
        logLine('Opening serial connection...');
        await selectedPort.open({
            baudRate: 115200,
            dataBits: 8,
            parity: "none",
            stopBits: 1,
            flowControl: "none"
        });

        port = selectedPort;
        logLine(`✅ Connected to serial port at 115200 baud.`);
        
        // Allow Arduino to reset (critical for stable connection)
        logLine('⏳ Waiting for Arduino to initialize (2 seconds)...');
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Setup readers and writers with proper stream tracking
        setupSerialStreams();
        
        isConnecting = false;
        
        // Connection established - test CLI responsiveness and initialize I2C
        logLine('✅ Serial connection established.');
        
        // Perform CLI handshake to verify device responsiveness
        logLine('🔍 Testing device responsiveness...');
        await performCLIHandshake();
        
        // Skip I2C init - firmware appears to work without it (like August)
        logLine('🔧 Firmware ready for EEPROM operations');
        
        logLine('✅ Device initialization completed.');
        
        // Update UI
        btnConnect.textContent = '✅ Connected';
        btnConnect.disabled = true;
        btnConnect.classList.remove('btn-primary');
        btnConnect.classList.add('btn-success');
        
        if (btnGetBoard) {
            btnGetBoard.disabled = false;
        }

        logLine('🎉 Connection established successfully!');
        logLine('You can now click "Read Circuit from Board" to scan for components.');

    } catch (err) {
        console.error("Error opening port:", err);
        logLine(`❌ Error opening port: ${err.message}`);
        
        // Specific error handling
        if (err.message.includes('Failed to open serial port')) {
            logLine('💡 Try: 1) Check if another program is using the port 2) Unplug and reconnect the Arduino 3) Select a different port');
        } else if (err.message.includes('not found')) {
            logLine('💡 Port not found. Try refreshing ports or reconnecting the Arduino.');
        }
        
        port = null;
        isConnecting = false;  // CRITICAL FIX: Reset connection flag on error
        
        // Reset UI
        btnConnect.textContent = 'Connect';
        btnConnect.disabled = false;
        btnConnect.classList.remove('btn-success');
        btnConnect.classList.add('btn-primary');
        
        if (btnGetBoard) {
            btnGetBoard.disabled = true;
        }
    }
}

// Disconnect from current port with proper stream teardown
async function disconnectPort() {
    if (port) {
        try {
            // Proper teardown sequence to prevent locked streams
            
            // 1. Cancel reader and await readable pipe
            if (reader) {
                await reader.cancel();
                reader = null;
            }
            
            if (readableStreamClosed) {
                await readableStreamClosed.catch(() => {});
                readableStreamClosed = null;
            }
            
            // 2. Close writer and await writable pipe
            if (writer) {
                await writer.close();
                writer = null;
            }
            
            if (writableStreamClosed) {
                await writableStreamClosed.catch(() => {});
                writableStreamClosed = null;
            }
            
            // 3. Clear stream references
            textDecoder = null;
            textEncoder = null;
            
            // 4. Finally close the port
            await port.close();
            logLine('Disconnected from serial port.');
            
        } catch (err) {
            console.error('Error disconnecting:', err);
            logLine(`Error disconnecting: ${err.message}`);
        }
        
        port = null;
        isConnecting = false;  // Reset connection flag
        
        // Reset UI
        btnConnect.textContent = 'Connect';
        btnConnect.disabled = false;
        btnConnect.classList.remove('btn-success');
        btnConnect.classList.add('btn-primary');
        
        if (btnGetBoard) {
            btnGetBoard.disabled = true;
        }
    }
}

// Setup serial communication streams with proper tracking
function setupSerialStreams() {
    if (!port) return;

    try {
        // Setup text decoder stream for reading with pipe tracking
        textDecoder = new TextDecoderStream();
        readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
        reader = textDecoder.readable.getReader();

        // Setup text encoder stream for writing with pipe tracking
        textEncoder = new TextEncoderStream();
        writableStreamClosed = textEncoder.readable.pipeTo(port.writable);
        writer = textEncoder.writable.getWriter();

        // Start reading loop
        readLoop();
        
    } catch (err) {
        console.error("Error setting up streams:", err);
        logLine(`Error setting up communication: ${err.message}`);
    }
}

// Continuous reading loop
async function readLoop() {
    while (port && reader) {
        try {
            const { value, done } = await reader.read();
            if (done) {
                break;
            }
            
            if (value) {
                // Use buffered line assembly to prevent hex data corruption
                lineBuffer += value;
                const lines = lineBuffer.split(/\r?\n/);
                
                // Log all complete lines except the last (which may be partial)
                for (let i = 0; i < lines.length - 1; i++) {
                    if (lines[i].trim()) {
                        logLine(lines[i].trim());
                    }
                }
                
                // Keep the last fragment as it might be partial
                lineBuffer = lines[lines.length - 1];
            }
        } catch (err) {
            console.error("Read error:", err);
            logLine(`Read error: ${err.message}`);
            break;
        }
    }
}

// Send command to device using tracked writer
async function sendCommand(command) {
    if (!port || !writer || isConnecting) {
        logLine('Error: Not connected to any port.');
        return false;
    }

    try {
        // Use the tracked writer instead of creating new ones
        await writer.write(command + "\r\n");
        
        // Small delay to ensure command is fully transmitted
        await new Promise(resolve => setTimeout(resolve, 100));
        
        logLine(`> ${command}`);
        return true;
    } catch (err) {
        console.error("Write error:", err);
        logLine(`Write error: ${err.message}`);
        return false;
    }
}

// Wait for complete response from device (like Python's buffer draining)
async function waitForCompleteResponse(timeoutMs = 2000) {
    return new Promise(resolve => {
        const startTime = Date.now();
        let lastLineCount = LOG_LINES.length;
        let stableCount = 0;
        
        function checkForStability() {
            const currentLineCount = LOG_LINES.length;
            
            if (currentLineCount === lastLineCount) {
                stableCount++;
                if (stableCount >= 4) { // 200ms of stability (4 * 50ms)
                    resolve();
                    return;
                }
            } else {
                stableCount = 0;
                lastLineCount = currentLineCount;
            }
            
            if (Date.now() - startTime > timeoutMs) {
                resolve();
                return;
            }
            
            setTimeout(checkForStability, 50);
        }
        
        // Wait at least 100ms before checking
        setTimeout(checkForStability, 100);
    });
}

// Backward compatibility alias
async function waitForResponse(timeoutMs = 2000) {
    return waitForCompleteResponse(timeoutMs);
}

// Wait for command prompt (V7 strategy - MUCH more reliable!)
async function waitForPrompt(timeoutMs = 6000) {
    const startTime = Date.now();
    const startLogLength = LOG_LINES.length;
    
    return new Promise(resolve => {
        const checkInterval = setInterval(() => {
            // Only check recent lines for performance (V7 fix)
            const recentLines = LOG_LINES.slice(Math.max(0, LOG_LINES.length - 10));
            const hasPrompt = recentLines.some(line => 
                line.trim().endsWith('>') || line.includes('$')
            );
            
            if (hasPrompt || (Date.now() - startTime) > timeoutMs) {
                clearInterval(checkInterval);
                resolve();
            }
        }, 100);
    });
}

// Legacy function kept for compatibility but redirects to prompt-based wait
async function waitForEEPROMReadComplete(timeoutMs = 6000) {
    return waitForPrompt(timeoutMs);
}

// Wait for hex dump to complete with prompt-based detection (V7 strategy)
async function waitForHexDumpComplete(timeoutMs = 6000) {
    // Use prompt-based wait instead of trying to parse hex lines
    // This is much more reliable and matches V7 behavior
    return waitForPrompt(timeoutMs);
}

// Perform CLI handshake to verify device responsiveness (like August logs)
async function performCLIHandshake() {
    // Clear line buffer for fresh start
    lineBuffer = '';
    const beforeLength = LOG_LINES.length;
    
    // Send newlines to wake up CLI
    logLine('Sending wake-up sequence...');
    await writer.write('\n\n');
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Try simple probe commands to verify responsiveness
    logLine('Testing CLI responsiveness with probe commands...');
    
    // Try help command
    await writer.write('help\r\n');
    await new Promise(resolve => setTimeout(resolve, 800));
    
    // Try version command  
    await writer.write('ver\r\n');
    await new Promise(resolve => setTimeout(resolve, 800));
    
    // Check if we got ANY response from device
    const newLines = LOG_LINES.slice(beforeLength);
    const responsiveLines = newLines.filter(line => 
        line.includes('Token:') || line.includes('$') || line.includes('Selected') || 
        line.includes('MUX') || line.includes('help') || line.includes('version') ||
        line.trim().length > 0 && !line.startsWith('>')
    );
    
    if (responsiveLines.length > 0) {
        logLine(`✅ Device is responding! Got ${responsiveLines.length} response lines`);
        // Log some sample responses
        responsiveLines.slice(0, 3).forEach(line => logLine(`📝 Response: "${line}"`));
    } else {
        logLine('⚠️ Device not responding to probe commands');
        logLine('This may indicate firmware issues or wrong port');
        
        // Try DTR/RTS toggle to wake up device
        logLine('Attempting to wake device with DTR/RTS toggle...');
        try {
            await port.setSignals({dataTerminalReady: true, requestToSend: false});
            await new Promise(resolve => setTimeout(resolve, 100));
            await port.setSignals({dataTerminalReady: false, requestToSend: true});
            await new Promise(resolve => setTimeout(resolve, 500));
        } catch (err) {
            logLine(`Signal toggle failed: ${err.message}`);
        }
    }
}

// Initialize I2C bus (CRITICAL - was being skipped!)
async function initializeI2CBus() {
    logLine('Initializing I2C bus and EEPROM systems...');
    
    // Send I2C initialization commands that might be needed
    const initCommands = [
        'i2c begin',    // Initialize I2C
        'i2c speed 400000',  // Set I2C speed to FAST mode (400 kHz) - CRITICAL V7 FIX!
        'eeprom init',  // Initialize EEPROM subsystem
        'eeprom addr 0x50',  // Set EEPROM address (common for 11AA010)
        'scan'  // Scan for I2C devices
    ];
    
    for (const cmd of initCommands) {
        logLine(`Sending: ${cmd}`);
        try {
            await sendCommand(cmd);
            await new Promise(resolve => setTimeout(resolve, 300));
        } catch (err) {
            logLine(`Command \"${cmd}\" failed: ${err.message}`);
        }
    }
    
    // Wait for initialization to complete
    await new Promise(resolve => setTimeout(resolve, 1000));
    logLine('I2C initialization sequence completed');
}

// Read complete board configuration
async function readBoardConfiguration() {
    if (!port) {
        alert("Please connect to a COM port first.");
        return;
    }

    // Disable button and show progress
    btnGetBoard.disabled = true;
    btnGetBoard.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Reading Board...';
    
    // Clear previous logs and results
    LOG_LINES = [];
    if (eepromLogArea) {
        eepromLogArea.value = '';
    }
    
    logLine('Starting board configuration read...');
    logLine('This will scan all MUX channels for component data.');
    
    try {
        // CRITICAL V7 FIX: Initialize I2C bus first (this was missing!)
        await initializeI2CBus();
        logLine('I2C bus initialized successfully - ready for fast EEPROM reads');
        
        // Read all MUX channels (A and B, 0-15 each) - EXACTLY like August working version
        const muxChannels = ['a', 'b'];
        const channelRange = Array.from({length: 16}, (_, i) => i);
        
        for (const mux of muxChannels) {
            logLine(`\n=== Scanning MUX ${mux.toUpperCase()} ===`);
            
            for (const channel of channelRange) {
                logLine(`\n--- MUX ${mux.toUpperCase()}, Channel ${channel} ---`);
                
                // Select MUX and channel (single MUX only - like August)
                const selectCmd = `sm ${mux} ${channel}`;
                if (!(await sendCommand(selectCmd))) {
                    continue;
                }
                await waitForPrompt(2000);
                
                // Check if MUX selection failed
                const recentLog = LOG_LINES.slice(-3).join(' ').toLowerCase();
                if (recentLog.includes('error') || recentLog.includes('fail')) {
                    logLine(`Skipping channel ${channel} - MUX selection failed`);
                    continue;
                }
                
                // Read EEPROM into buffer FIRST (this was missing!)
                logLine('Reading EEPROM data into buffer...');
                await sendCommand('er 0 64');  // Read 64 bytes from address 0
                
                // Wait specifically for EEPROM read completion (V7 TIMING!)
                await waitForEEPROMReadComplete(6000);
                
                // Additional delay to ensure data is fully buffered
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Then hex dump the buffer - FIRST attempt (often fails like August)
                const hexLinesBefore = LOG_LINES.filter(line => line.match(/^\s*[0-9A-Fa-f]{2,4}:\s+(?:[0-9A-Fa-f]{2}\s+){8,}/)).length;
                await sendCommand('hd 0 16');  // Hex dump starting from address 0
                await waitForHexDumpComplete(6000);
                
                // Only retry if no hex data was captured from first attempt
                const hexLinesAfter = LOG_LINES.filter(line => line.match(/^\s*[0-9A-Fa-f]{2,4}:\s+(?:[0-9A-Fa-f]{2}\s+){8,}/)).length;
                if (hexLinesAfter === hexLinesBefore) {
                    // No hex data from first attempt - try second attempt like August pattern
                    logLine('First attempt failed, retrying...');
                    await new Promise(resolve => setTimeout(resolve, 300));
                    await sendCommand('hd 0 16');  // Use correct syntax with start address
                    await waitForHexDumpComplete(6000);
                }
                
                // Wait for EEPROM to settle before next channel
                await new Promise(resolve => setTimeout(resolve, 750));
            }
        }
        
        logLine('\n=== Board scan completed ===');
        
        // Use backend to parse the log and populate the board
        await parseLogWithBackend();
        
    } catch (err) {
        console.error("Board reading error:", err);
        logLine(`Error reading board: ${err.message}`);
        
        if (errorDisplay) {
            errorDisplay.textContent = `Board reading failed: ${err.message}`;
            errorDisplay.style.display = 'block';
        }
        
    } finally {
        // Re-enable button
        btnGetBoard.disabled = false;
        btnGetBoard.innerHTML = '<i class="fas fa-download me-2"></i>Read Circuit from Board';
    }
}

// Create analyze button
function createAnalyzeButton() {
    const btn = document.createElement('button');
    btn.id = 'btn-analyze-log';
    btn.className = 'btn btn-info mt-2 ms-2';
    btn.innerHTML = '<i class="fas fa-stethoscope me-2"></i>Analyze Issue';
    btn.style.display = 'none';
    
    const container = document.querySelector('#btn-get-board').parentNode;
    container.appendChild(btn);
    
    return btn;
}

// Create debug hex button
function createDebugHexButton() {
    const btn = document.createElement('button');
    btn.id = 'btn-debug-hex';
    btn.className = 'btn btn-warning mt-2';
    btn.innerHTML = '<i class="fas fa-bug me-2"></i>Show Raw Hex Data';
    btn.style.display = 'none';
    
    const container = document.querySelector('#btn-get-board').parentNode;
    container.appendChild(btn);
    
    return btn;
}

// Show raw hex data for debugging
function showRawHexData(channelData) {
    logLine('\n=== RAW HEX DATA DEBUG ===');
    logLine('This shows exactly what your EEPROMs contain:');
    logLine('');
    
    // Get the original log lines that contain hex data
    const hexLines = LOG_LINES.filter(line => 
        line.includes('00:') || line.includes('40:') || 
        line.includes('sm a') || line.includes('sm b')
    );
    
    let currentChannel = null;
    for (const line of hexLines) {
        // Look for MUX commands
        const cmdMatch = line.match(/>\s*sm\s+([ab])\s+(\d+)/i);
        if (cmdMatch) {
            const muxLetter = cmdMatch[1].toUpperCase();
            const channelNum = parseInt(cmdMatch[2], 10);
            currentChannel = `MUX_${muxLetter}_CH_${channelNum}`;
            logLine(`\n--- ${currentChannel} ---`);
            continue;
        }
        
        // Show hex dump lines
        if (currentChannel && (line.includes('00:') || line.includes('40:'))) {
            logLine(`${line}`);
            
            // Try to show ASCII interpretation
            const hexMatch = line.match(/^[0-7][0-9A-Fa-f]:\s*(.+)/);
            if (hexMatch) {
                const hexPart = hexMatch[1].split(/\s{3,}/)[0]; // Take only hex part
                const hexBytes = hexPart.match(/[0-9A-Fa-f]{2}/g) || [];
                
                let ascii = '';
                for (const hex of hexBytes) {
                    const byte = parseInt(hex, 16);
                    if (byte >= 32 && byte <= 126) {
                        ascii += String.fromCharCode(byte);
                    } else if (byte === 0) {
                        ascii += '\\0'; // Show null bytes
                    } else {
                        ascii += '.'; // Non-printable
                    }
                }
                
                if (ascii.replace(/\.|\\0/g, '').length > 0) {
                    logLine(`     ASCII: "${ascii}"`);
                }
            }
        }
    }
    
    logLine('\n=== INTERPRETATION ===');
    logLine('Expected component name format examples:');
    logLine('  - "promoter_lac" or "promoter_a"');
    logLine('  - "rbs_strong" or "rbs_b"'); 
    logLine('  - "cds_gfp" or "cds_c"');
    logLine('');
    logLine('What we actually found:');
    for (const [channel, components] of Object.entries(channelData)) {
        if (components.length > 0 && channel !== '_scan_stats') {
            logLine(`  ${channel}: ${components.join(', ')}`);
        }
    }
    logLine('');
    logLine('If these don\'t match what you expect, the EEPROMs may contain');
    logLine('different data than anticipated, or may need reprogramming.');
}

// Show Transfer to Designer button when circuit is successfully read
function showTransferToDesignerButton(cellboard) {
    const transferBtn = document.getElementById('btn-transfer-designer');
    if (transferBtn) {
        transferBtn.style.display = 'inline-block';
        
        // Add click handler to navigate to designer with circuit data
        transferBtn.onclick = function() {
            // Navigate to main designer page
            window.location.href = '/';
        };
    }
}

// Use backend to parse EEPROM log data
async function parseLogWithBackend() {
    try {
        logLine('\n=== Sending log data to backend for parsing ===');
        
        const response = await fetch('/interpret_hardware', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ log_lines: LOG_LINES })
        });
        
        const result = await response.json();
        
        if (result.status === 'success') {
            logLine(`Backend parsing successful! Found ${result.component_count} components.`);
            
            // Log the parsed channel data with debug info
            for (const [channel, components] of Object.entries(result.channel_data)) {
                if (components.length > 0) {
                    logLine(`${channel}: ${components.join(', ')}`);
                }
            }
            
            // Add debug button to show raw hex data
            const debugBtn = document.getElementById('btn-debug-hex') || createDebugHexButton();
            debugBtn.style.display = 'inline-block';
            debugBtn.onclick = () => showRawHexData(result.channel_data);
            
            // Also add analyze button for immediate diagnosis
            const analyzeBtn = document.getElementById('btn-analyze-log') || createAnalyzeButton();
            analyzeBtn.style.display = 'inline-block';
            analyzeBtn.onclick = () => analyzeScanFailure();
            
            // Populate board from the backend-parsed cellboard data
            if (result.cellboard && Object.keys(result.cellboard).length > 0) {
                populateBoardFromCellboard(result.cellboard);
                
                // Save circuit data to localStorage for transfer to main designer
                localStorage.setItem('hardwareCircuitData', JSON.stringify({
                    cellboard: result.cellboard,
                    timestamp: Date.now(),
                    source: 'hardware_board'
                }));
                
                logLine('\nCircuit data saved for transfer to main designer!');
                
                // Show transfer button
                showTransferToDesignerButton(result.cellboard);
                
                // Run simulation with the detected circuit
                logLine('\nRunning simulation with detected circuit...');
                await runSimulationFromCellboard(result.cellboard);
            } else {
                logLine('');
                logLine('=== Board Scan Complete ===');
                logLine('No circuit components detected. This is normal if:');
                logLine('  1. Your board has no EEPROMs connected');
                logLine('  2. The EEPROMs are empty/unprogrammed');
                logLine('  3. This is a fresh hardware setup');
                logLine('');
                logLine('Next steps:');
                logLine('  - Use the main Circuit Designer to create virtual circuits');
                logLine('  - Or connect programmed EEPROMs with component data');
                logLine('  - The hardware communication is working correctly!');
            }
            
        } else {
            logLine(`Backend parsing failed: ${result.message}`);
            
            // Analyze the failure and provide helpful diagnostics
            analyzeScanFailure();
            
            // Fallback to client-side parsing
            logLine('Falling back to client-side parsing...');
            parseLogAndPopulateBoard();
        }
        
    } catch (err) {
        console.error('Backend parsing error:', err);
        logLine(`Backend parsing error: ${err.message}`);
        
        // Fallback to client-side parsing
        logLine('Falling back to client-side parsing...');
        parseLogAndPopulateBoard();
    }
}

// Parse EEPROM log and extract component data (fallback method)
function parseLogAndPopulateBoard() {
    const channelData = {};
    let currentChannel = null;
    
    logLine('\n=== Parsing component data (client-side) ===');
    
    for (const line of LOG_LINES) {
        // Look for MUX selection commands
        const cmdMatch = line.match(/>\s*sm\s+([ab])\s+(\d+)/i);
        if (cmdMatch) {
            const muxLetter = cmdMatch[1].toUpperCase();
            const channelNum = parseInt(cmdMatch[2], 10);
            currentChannel = `MUX ${muxLetter}, Channel ${channelNum}`;
            channelData[currentChannel] = [];
            continue;
        }
        
        // Parse hex dump lines in format "00: 68 65 6C 6C ..."
        if (currentChannel && line.match(/^[0-7][0-9A-Fa-f]:/)) {
            const parts = line.split(':');
            if (parts.length === 2) {
                const hexValues = parts[1].trim().split(/\s+/).slice(0, 16); // Take only hex values
                let componentString = '';
                
                // Convert hex to ASCII characters
                for (const hexValue of hexValues) {
                    if (hexValue.length === 2) {
                        try {
                            const charCode = parseInt(hexValue, 16);
                            if (charCode >= 32 && charCode <= 126) { // Printable ASCII range
                                componentString += String.fromCharCode(charCode);
                            }
                        } catch (e) {
                            // Skip invalid hex values
                        }
                    }
                }
                
                // Extract component identifiers from the ASCII string
                if (componentString.trim()) {
                    // Look for patterns like "promoter_1", "rbs_1", "cds_1", etc.
                    const componentMatches = componentString.match(/[a-zA-Z_]+_?\d*/g);
                    if (componentMatches) {
                        componentMatches.forEach(match => {
                            const componentName = match.trim();
                            if (componentName && !channelData[currentChannel].includes(componentName)) {
                                channelData[currentChannel].push(componentName);
                            }
                        });
                    }
                }
            }
        }
    }
    
    // Remove empty channels
    Object.keys(channelData).forEach(key => {
        if (channelData[key].length === 0) {
            delete channelData[key];
        } else {
            // Remove duplicates
            channelData[key] = [...new Set(channelData[key])];
        }
    });
    
    logLine(`Found components in ${Object.keys(channelData).length} channels.`);
    
    // Populate the visual board
    populateBoardFromChannelData(channelData);
}

// Populate board from backend cellboard format
function populateBoardFromCellboard(cellboard) {
    // Clear existing components
    document.querySelectorAll(".cell .placed-component").forEach(el => el.remove());
    document.querySelectorAll(".cell").forEach(cell => {
        cell.style.backgroundColor = '';
        cell.style.color = '';
        cell.textContent = '';
        cell.classList.remove('has-component');
    });
    
    let totalComponents = 0;
    
    for (const [componentType, components] of Object.entries(cellboard)) {
        components.forEach(comp => {
            const x = parseInt(comp.x);
            const y = parseInt(comp.y);
            
            // Find the corresponding cell
            const cell = document.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
            if (!cell) return;
            
            // Create component object
            const component = {
                name: `${componentType.toLowerCase()}_${comp.gene.split(' ')[1]}`,
                type: componentType,
                gene: comp.gene.split(' ')[1],
                strength: comp.strength
            };
            
            createPlacedComponent(cell, component);
            totalComponents++;
        });
    }
    
    logLine(`Total components placed on board: ${totalComponents}`);
}

// Run simulation with cellboard data
async function runSimulationFromCellboard(cellboard) {
    try {
        const response = await fetch("/simulate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ cellboard: cellboard })
        });
        
        const result = await response.json();
        
        if (result.status === "success") {
            logLine('Hardware circuit simulation completed successfully!');
            
            // Display plot
            if (result.plot && plotContainer) {
                plotContainer.innerHTML = `
                    <div class="card">
                        <div class="card-header">
                            <h5><i class="fas fa-chart-line me-2"></i>Hardware Circuit Simulation</h5>
                        </div>
                        <div class="card-body text-center">
                            <img src="data:image/png;base64,${result.plot}" 
                                 alt="Hardware Circuit Simulation" 
                                 class="img-fluid" 
                                 style="max-width:100%; border-radius: 8px;">
                        </div>
                    </div>
                `;
            }
            
            // Log additional information
            if (result.equations) {
                logLine(`Generated ${Object.keys(result.equations).length} differential equations.`);
            }
            if (result.regulations) {
                const nonConstitutive = result.regulations.filter(r => r.type !== 'constitutive').length;
                logLine(`Detected ${nonConstitutive} regulatory interactions.`);
            }
            
        } else {
            logLine(`Hardware simulation failed: ${result.message}`);
            
            if (errorDisplay) {
                errorDisplay.textContent = result.message;
                errorDisplay.style.display = 'block';
            }
        }
        
    } catch (err) {
        console.error("Hardware simulation error:", err);
        logLine(`Hardware simulation error: ${err.message}`);
        
        if (errorDisplay) {
            errorDisplay.textContent = "Hardware simulation request failed.";
            errorDisplay.style.display = 'block';
        }
    }
}

// Diagnose individual EEPROMs to see what data they contain
async function diagnoseBoardEEPROMs() {
    if (!port) {
        alert("Please connect to a COM port first.");
        return;
    }

    // Disable button and show progress
    btnDiagnoseBoard.disabled = true;
    btnDiagnoseBoard.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Diagnosing...';
    
    // Clear previous logs
    LOG_LINES = [];
    if (eepromLogArea) {
        eepromLogArea.value = '';
    }
    
    logLine('=== EEPROM Diagnostic Mode ===');
    logLine('Checking each MUX channel for any stored data...');
    logLine('This will show you exactly what is stored on your EEPROMs.');
    
    try {
        // Test channels where your components should be located
        const testChannels = [
            {mux: 'a', channel: 0}, {mux: 'a', channel: 1}, {mux: 'a', channel: 2}, {mux: 'a', channel: 3},
            {mux: 'b', channel: 0}, {mux: 'b', channel: 1}, {mux: 'b', channel: 2}, {mux: 'b', channel: 3}
        ];
        
        for (const {mux, channel} of testChannels) {
            logLine(`\n--- Testing MUX ${mux.toUpperCase()}, Channel ${channel} ---`);
            
            // Select MUX and channel
            const selectCmd = `sm ${mux} ${channel}`;
            if (!(await sendCommand(selectCmd))) {
                continue;
            }
            await waitForResponse(1000);
            
            // Read EEPROM into buffer then hex dump (correct sequence)
            logLine('Reading EEPROM data into buffer...');
            await sendCommand('er 0 128');  // Read 128 bytes from address 0  
            await waitForResponse(1000);
            
            logLine('Hex dumping EEPROM content...');
            await sendCommand('hd 0 128');  // Hex dump starting from address 0
            await waitForResponse(2000);
            
            // Wait between channels
            await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        logLine('\n=== Diagnostic scan completed ===');
        logLine('Analyzing raw data for any readable content...');
        
        // Parse with enhanced detection
        await parseLogWithBackend();
        
    } catch (err) {
        console.error("Diagnostic error:", err);
        logLine(`Error during diagnostic: ${err.message}`);
        
    } finally {
        // Re-enable button
        btnDiagnoseBoard.disabled = false;
        btnDiagnoseBoard.innerHTML = '<i class="fas fa-search me-2"></i>Diagnose EEPROMs';
    }
}

// Populate visual board from parsed channel data
function populateBoardFromChannelData(channelData) {
    // Clear existing components
    document.querySelectorAll(".cell .placed-component").forEach(el => el.remove());
    document.querySelectorAll(".cell").forEach(cell => {
        cell.style.backgroundColor = '';
        cell.style.color = '';
        cell.textContent = '';
        cell.classList.remove('has-component');
    });
    
    let totalComponents = 0;
    
    for (const channelKey in channelData) {
        const components = channelData[channelKey];
        
        // Parse channel information
        const channelMatch = channelKey.match(/MUX\s+([AB]),\s*Channel\s*(\d+)/);
        if (!channelMatch) continue;
        
        const muxLetter = channelMatch[1];
        const channelNum = parseInt(channelMatch[2], 10);
        
        // Map to board position (8x8 grid)
        // MUX A maps to channels 0-15, MUX B maps to channels 16-31
        const linearPosition = (muxLetter === 'A' ? channelNum : channelNum + 16);
        const row = Math.floor(linearPosition / 8);
        const col = linearPosition % 8;
        
        // Find the corresponding cell
        const cell = document.querySelector(`.cell[data-x="${col}"][data-y="${row}"]`);
        if (!cell) continue;
        
        // Place components in the cell - handle multiple components per channel
        components.forEach((componentName, index) => {
            logLine(`Parsing component: "${componentName}"`);
            const component = parseComponentName(componentName);
            if (component) {
                logLine(`Successfully parsed: ${componentName} → ${component.type} ${component.gene}`);
                // For multiple components in same cell, offset them slightly
                const offsetCell = cell;
                if (index > 0) {
                    // Create a visual indicator for multiple components
                    offsetCell.style.border = '2px solid #ffd700';
                    offsetCell.title = `Multiple components: ${components.join(', ')}`;
                }
                createPlacedComponent(offsetCell, component);
                totalComponents++;
            } else {
                logLine(`Failed to parse component: "${componentName}"`);
            }
        });
        
        logLine(`Channel ${channelKey}: ${components.join(', ')}`);
    }
    
    logLine(`\nTotal components placed: ${totalComponents}`);
    
    // Run simulation if components were found
    if (totalComponents > 0) {
        logLine(`Running simulation with ${totalComponents} detected components...`);
        runSimulationAfterPopulation();
    } else {
        logLine('No valid components detected on the board.');
        logLine('This might be due to component naming format. Check the diagnostic output above.');
    }
}

// Parse component name to extract type and gene
function parseComponentName(name) {
    // Map based on Excel file component naming format
    const cleanName = name.toLowerCase().trim();
    
    // Check component type based on Excel file format
    if (cleanName.includes('promotor') || cleanName === 'omo') {
        return {
            name: name,
            type: 'Promoter',
            gene: extractGeneFromName(name),
            strength: 'norm'
        };
    }
    
    if (cleanName.startsWith('rbs')) {
        return {
            name: name,
            type: 'RBS', 
            gene: extractGeneFromName(name),
            strength: 'norm'
        };
    }
    
    if (cleanName.startsWith('cds')) {
        return {
            name: name,
            type: 'CDS',
            gene: extractGeneFromName(name), 
            strength: 'norm'
        };
    }
    
    if (cleanName.startsWith('terminator') || cleanName === 'termi') {
        return {
            name: name,
            type: 'Terminator',
            gene: extractGeneFromName(name),
            strength: 'norm'
        };
    }
    
    if (cleanName.startsWith('repressor') || cleanName.startsWith('r_') || cleanName === 'r_a' || cleanName === 'r_b') {
        return {
            name: name,
            type: 'Repressor',
            gene: extractGeneFromName(name),
            strength: 'norm'
        };
    }
    
    if (cleanName.startsWith('activator')) {
        return {
            name: name,
            type: 'Activator',
            gene: extractGeneFromName(name),
            strength: 'norm'
        };
    }
    
    if (cleanName === 'or' || cleanName === 'or_a' || cleanName.includes('operator')) {
        return {
            name: name,
            type: 'Operator',
            gene: extractGeneFromName(name),
            strength: 'norm'
        };
    }
    
    // If no match found, log it
    logLine(`Unknown component name: ${name}`);
    return null;
}

// Helper function to extract gene identifier from component name
function extractGeneFromName(name) {
    const match = name.match(/_([a-z])(?:_|$)/i);
    return match ? match[1].toUpperCase() : '1';
}

// Create visual component on board AND add to state
function createPlacedComponent(cell, component) {
    const placedEl = document.createElement("div");
    placedEl.className = "placed-component";
    placedEl.textContent = component.name;
    placedEl.dataset.component = component.type;
    placedEl.dataset.gene = component.gene;
    placedEl.dataset.strength = component.strength;
    
    // Apply component styling
    const colors = {
        'Promoter': '#FF6B6B',
        'Terminator': '#4ECDC4',
        'RBS': '#FFD166',
        'CDS': '#06D6A0',
        'Repressor Start': '#A78BFA',
        'Repressor End': '#7E22CE',
        'Activator Start': '#3B82F6',
        'Activator End': '#1E40AF'
    };
    
    placedEl.style.backgroundColor = colors[component.type] || '#999';
    placedEl.style.color = 'white';
    placedEl.style.fontWeight = 'bold';
    placedEl.style.fontSize = '0.6rem';
    placedEl.style.padding = '2px';
    placedEl.style.borderRadius = '2px';
    placedEl.style.textAlign = 'center';
    
    cell.appendChild(placedEl);
    cell.classList.add('has-component');
    
    // IMPORTANT: Add to state so simulation can find it
    const x = cell.dataset.x;
    const y = cell.dataset.y;
    
    // Auto-increment component number based on type (like dial mode)
    const baseType = component.type.toLowerCase().replace(' ', '_');
    if (!state.componentCounts[baseType]) {
        state.componentCounts[baseType] = 1;
    } else {
        state.componentCounts[baseType]++;
    }
    
    const stateComponent = {
        type: component.type,
        number: state.componentCounts[baseType],
        strength: component.strength || 'norm',
        x: x,
        y: y,
        id: Date.now() + Math.random(),
        customName: component.name, // Use the parsed name
        parameters: {} // For component parameters
    };
    
    state.placedComponents.push(stateComponent);
    console.log(`Added component to state: ${component.type} at (${x}, ${y})`);
}

// Run simulation with populated board
async function runSimulationAfterPopulation() {
    const placedComponents = [];
    
    // Collect all placed components
    document.querySelectorAll(".placed-component").forEach(el => {
        const cell = el.parentElement;
        const type = el.dataset.component;
        const gene = el.dataset.gene;
        const strength = el.dataset.strength;
        const x = cell.dataset.x;
        const y = cell.dataset.y;
        
        placedComponents.push({
            type: type,
            gene: `Gene ${gene}`,
            strength: strength,
            x: x,
            y: y
        });
    });
    
    if (placedComponents.length === 0) {
        logLine('No components to simulate.');
        return;
    }
    
    // Prepare cellboard data
    const cellboard = placedComponents.reduce((acc, comp) => {
        if (!acc[comp.type]) {
            acc[comp.type] = [];
        }
        acc[comp.type].push({
            gene: comp.gene,
            strength: comp.strength,
            x: comp.x,
            y: comp.y
        });
        return acc;
    }, {});
    
    try {
        // Send simulation request
        const response = await fetch("/simulate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ cellboard: cellboard })
        });
        
        const result = await response.json();
        
        if (result.status === "success") {
            logLine('Simulation completed successfully!');
            
            // Display plot
            if (result.plot && plotContainer) {
                plotContainer.innerHTML = `
                    <img src="data:image/png;base64,${result.plot}" 
                         alt="Hardware Circuit Simulation" 
                         class="plot-image" 
                         style="max-width:100%;">
                `;
            }
            
            // Log circuit information
            if (result.circuits) {
                logLine(`Detected ${result.circuits.length} circuit(s).`);
            }
            if (result.regulations) {
                logLine(`Found ${result.regulations.length} regulatory interaction(s).`);
            }
            
        } else {
            logLine(`Simulation failed: ${result.message}`);
            
            if (errorDisplay) {
                errorDisplay.textContent = result.message;
                errorDisplay.style.display = 'block';
            }
        }
        
    } catch (err) {
        console.error("Simulation request failed:", err);
        logLine(`Simulation request failed: ${err.message}`);
        
        if (errorDisplay) {
            errorDisplay.textContent = "Simulation request failed.";
            errorDisplay.style.display = 'block';
        }
    }
}

// Log message to UI and internal log
function logLine(message) {
    // Add to internal log
    LOG_LINES.push(message);
    
    // Add to UI log area
    if (eepromLogArea) {
        eepromLogArea.value += message + "\n";
        eepromLogArea.scrollTop = eepromLogArea.scrollHeight;
    }
    
    // Also log to console for debugging
    console.log('EEPROM:', message);
}

// Analyze scan failure to provide helpful diagnostics
function analyzeScanFailure() {
    logLine('\n=== DIAGNOSTIC ANALYSIS ===');
    
    // Count different types of responses
    let totalMuxCommands = 0;
    let successfulMuxCommands = 0;
    let totalHexDumps = 0;
    let successfulHexDumps = 0;
    let hexDataFound = 0;
    let failLines = 0;
    
    // Track which hex dumps got data vs failed
    let hexDumpLines = [];
    let currentHexDumpHasData = false;
    
    for (let i = 0; i < LOG_LINES.length; i++) {
        const line = LOG_LINES[i];
        
        // Count MUX commands
        if (line.match(/>\s*sm\s+[ab]\s+\d+/)) {
            totalMuxCommands++;
        }
        
        // Count successful MUX selections
        if (line.match(/MUX [AB], Channel \d+/) || line.match(/Selected MUX [AB], Channel \d+/)) {
            successfulMuxCommands++;
        }
        
        // Count hex dump attempts and track their success
        if (line.match(/>\s*hd\s+(16|64|128)/)) {
            // If we were tracking a previous hex dump, finalize it
            if (totalHexDumps > 0) {
                if (currentHexDumpHasData) {
                    successfulHexDumps++;
                }
            }
            
            totalHexDumps++;
            currentHexDumpHasData = false;
        }
        
        // Count lines that just say "fail"
        if (line.trim() === 'fail') {
            failLines++;
        }
        
        // Count actual hex data lines (broader pattern to catch more formats)
        if (line.match(/^\s*[0-9A-Fa-f]{2,4}:\s+(?:[0-9A-Fa-f]{2}\s+){8,}/)) {
            hexDataFound++;
            currentHexDumpHasData = true;
        }
    }
    
    // Finalize the last hex dump if any
    if (totalHexDumps > 0 && currentHexDumpHasData) {
        successfulHexDumps++;
    }
    
    // Provide diagnosis
    logLine(`Hardware Communication Status:`);
    logLine(`  • MUX Commands: ${successfulMuxCommands}/${totalMuxCommands} successful`);
    logLine(`  • Hex Dump Commands: ${successfulHexDumps}/${totalHexDumps} successful`);
    logLine(`  • Hex Data Lines Found: ${hexDataFound}`);
    
    logLine('\nDiagnosis:');
    
    if (successfulMuxCommands > 0 && successfulHexDumps === 0) {
        logLine('❌ ISSUE: No EEPROMs are responding to read commands');
        logLine('');
        logLine('Possible causes:');
        logLine('  1. No EEPROMs are physically connected to any MUX channels');
        logLine('  2. EEPROMs are connected but not properly wired (VCC, GND, SDA, SCL)');
        logLine('  3. EEPROMs are faulty or damaged');
        logLine('  4. Wrong EEPROM type (expecting 11AA010 or compatible)');
        logLine('  5. I2C address conflicts or wiring issues');
        logLine('');
        logLine('Next Steps:');
        logLine('  • Check physical EEPROM connections on your Cell Board');
        logLine('  • Verify EEPROM power (3.3V) and I2C wiring');
        logLine('  • Test with a known-good EEPROM programmed with component data');
        logLine('  • Use an I2C scanner to verify EEPROM addresses');
    } else if (totalMuxCommands === 0) {
        logLine('❌ ISSUE: No hardware communication detected');
        logLine('');
        logLine('Possible causes:');
        logLine('  • Serial port not connected properly');
        logLine('  • Wrong baud rate or communication settings'); 
        logLine('  • Hardware not powered on');
    } else {
        logLine('⚠️  PARTIAL ISSUE: Mixed communication results');
        logLine('');
        logLine('Some commands work but data reading is inconsistent.');
        logLine('This suggests intermittent connection or hardware issues.');
    }
}

// Clear log, board preview, and simulation results
function clearLogAndBoard() {
    // Clear internal log array
    LOG_LINES.length = 0;
    
    // Clear UI log area
    if (eepromLogArea) {
        eepromLogArea.value = '';
    }
    
    // Clear board preview - remove all placed components
    const placedComponents = document.querySelectorAll('.placed-component');
    placedComponents.forEach(component => {
        component.remove();
    });
    
    // Remove has-component class from cells
    const cellsWithComponents = document.querySelectorAll('.cell.has-component');
    cellsWithComponents.forEach(cell => {
        cell.classList.remove('has-component');
    });
    
    // Clear simulation results
    const plotContainer = document.getElementById('plot-container');
    if (plotContainer) {
        plotContainer.innerHTML = `
            <div class="loading">
                <i class="fas fa-microchip" style="color: var(--primary); font-size: 2rem;"></i>
                <p>Connect to hardware and read circuit configuration</p>
            </div>
        `;
    }
    
    // Clear error display
    const errorDisplay = document.getElementById('error-display');
    if (errorDisplay) {
        errorDisplay.style.display = 'none';
        errorDisplay.textContent = '';
    }
    
    // Hide transfer and debug buttons
    const transferBtn = document.getElementById('btn-transfer-designer');
    if (transferBtn) {
        transferBtn.style.display = 'none';
    }
    
    const debugBtn = document.getElementById('btn-debug-hex');
    if (debugBtn) {
        debugBtn.style.display = 'none';
    }
    
    const analyzeBtn = document.getElementById('btn-analyze-log');
    if (analyzeBtn) {
        analyzeBtn.style.display = 'none';
    }
    
    console.log('EEPROM: Log, board preview, and simulation results cleared');
}

// Removed duplicate global runSimulation function to avoid conflicts
// The runSimulation function is properly defined within the component initialization scope
        errorDisplay.style.display = 'none';
        errorDisplay.textContent = '';
    }

    // Show loading in plot container
    if (plotContainer) {
        plotContainer.innerHTML = `
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Simulating genetic circuit dynamics...</p>
            </div>
        `;
    }

    try {
        // Always sync from DOM first - this handles all existing components
        const domComponents = document.querySelectorAll('.placed-component');
        console.log(`Found ${domComponents.length} visual components on board`);
        
        if (domComponents.length === 0) {
            throw new Error('No components placed on the board. Please place some components first.');
        }
        
        // Build cellboard from DOM components (dial mode format)
        const cellboard = {};
        const componentCounts = {};
        
        domComponents.forEach((el, i) => {
            const cell = el.parentElement;
            const componentType = el.dataset.component || el.textContent.split(' ')[0] || 'Unknown';
            
            if (!cellboard[componentType]) {
                cellboard[componentType] = [];
            }
            
            // Auto-increment component number
            const baseType = componentType.toLowerCase().replace(' ', '_');
            if (!componentCounts[baseType]) {
                componentCounts[baseType] = 1;
            } else {
                componentCounts[baseType]++;
            }
            
            cellboard[componentType].push({
                x: cell.dataset.x,
                y: cell.dataset.y,
                type: componentType,
                strength: el.dataset.strength || 'norm',
                number: componentCounts[baseType]
            });
            
            console.log(`Component ${i+1}: ${componentType} at (${cell.dataset.x}, ${cell.dataset.y})`);
        });
        
        console.log('Prepared cellboard:', cellboard);
        
        // Prepare request data
        const requestData = { cellboard: cellboard };
        
        // Add dial data if available
        if (dialForm) {
            const toggle = document.getElementById('enable_dial_params');
            const includeDial = toggle ? toggle.checked : true;
            requestData.apply_dial = !!includeDial;
            
            if (includeDial) {
                const dialData = {};
                const inputs = dialForm.querySelectorAll('input[type="number"]:not([disabled])');
                console.log(`Collecting ${inputs.length} parameter inputs`);
                
                inputs.forEach(input => {
                    const paramName = input.name || input.id; // Fallback to id if name is missing
                    const value = parseFloat(input.value);
                    if (!isNaN(value) && paramName) {
                        dialData[paramName] = value;
                        console.log(`  - ${paramName}: ${value}`);
                    }
                });
                
                requestData.dial = dialData;
                console.log('Dial parameters collected:', Object.keys(dialData).length, 'parameters:', dialData);
            } else {
                console.log('Dial parameters disabled by toggle');
            }
        } else {
            console.warn('No dial form found - parameters will not be applied');
            requestData.apply_dial = false;
        }
        
        console.log('Sending simulation request:', requestData);
        
        // Send simulation request
        const response = await fetch('/simulate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(requestData)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.message || `Server error: ${response.status}`);
        }

        const result = await response.json();
        console.log('Simulation result:', result);

        if (result.status === 'success') {
            // Display results
            if (result.plot && plotContainer) {
                plotContainer.innerHTML = `
                    <img src="data:image/png;base64,${result.plot}" 
                         alt="Simulation Results" 
                         class="plot-image">
                `;
            } else if (plotContainer) {
                plotContainer.innerHTML = '<p class="text-center">Simulation completed successfully</p>';
            }

            // Add animation
            if (plotContainer) {
                plotContainer.classList.add('placed');
                setTimeout(() => {
                    plotContainer.classList.remove('placed');
                }, 300);
            }

            // Log detailed results
            if (result.circuits) {
                console.log('Detected circuits:', result.circuits);
            }
            if (result.regulations) {
                console.log('Regulatory networks:', result.regulations);
            }
            if (result.warnings && result.warnings.length > 0) {
                console.warn('Simulation warnings:', result.warnings);
            }

        } else {
            throw new Error(result.message || 'Unknown simulation error');
        }

    } catch (error) {
        console.error('Simulation failed:', error);
        
        // Display error
        if (errorDisplay) {
            errorDisplay.textContent = `Error: ${error.message}`;
            errorDisplay.style.display = 'block';
        }

        // Show error in plot container
        if (plotContainer) {
            plotContainer.innerHTML = `
                <div class="loading">
                    <i class="fas fa-exclamation-triangle" style="color: var(--error); font-size: 2rem;"></i>
                    <p>Simulation failed</p>
                    <small class="text-muted">${error.message}</small>
                </div>
            `;
        }

    } finally {
        // Re-enable button
        if (simulateBtn) {
            simulateBtn.disabled = false;
            simulateBtn.innerHTML = '<i class="fas fa-play me-2"></i>Run Simulation';
        }
    }
}

// Expose functions for debugging  
window.eepromInterface = {
    LOG_LINES,
    logLine,
    sendCommand,
    parseLogAndPopulateBoard,
    populateBoardFromChannelData,
    clearLogAndBoard,
    runSimulation
};

// Test function to debug button clicks
function testButtonClick() {
    console.log('Test button click function called');
    const simulateBtn = document.getElementById('simulate-btn');
    console.log('Simulate button:', simulateBtn);
    if (simulateBtn) {
        console.log('Button found, triggering click...');
        simulateBtn.click();
    } else {
        console.log('Button not found!');
    }
}

// Expose test function
window.testButtonClick = testButtonClick;

// Auto-test on load for debugging
setTimeout(() => {
    console.log('=== AUTO DEBUG TEST ===');
    const simulateBtn = document.getElementById('simulate-btn');
    console.log('Simulate button found:', !!simulateBtn);
    if (simulateBtn) {
        console.log('Button text:', simulateBtn.textContent.trim());
        console.log('Button disabled:', simulateBtn.disabled);
        console.log('Button listeners:', simulateBtn.onclick);
    }
    
    const placedComponents = document.querySelectorAll('.placed-component');
    console.log('Placed components found:', placedComponents.length);
    placedComponents.forEach((el, i) => {
        console.log(`  Component ${i+1}:`, el.textContent, 'at', el.parentElement.dataset.x, el.parentElement.dataset.y);
    });
}, 2000);

// Removed entire duplicate script section that was causing component selection conflicts

    function init() {
        setupGeneTabs();
        setupComponents();
        setupCells();
        setupDragAndDrop();
        setupDialToggle();

        // Initialize connector system for EEPROM interface
        if (!ConnectorManagerEEPROM.init()) {
            console.warn('ConnectorManagerEEPROM initialization failed - connector features disabled');
        }

        setupAddGeneButton();
        setupRemoveGeneButton();
        
        // Initialize with the first available Gene tab active (query dynamically)
        const firstTab = document.querySelector('#gene-tabs .gene-tab');
        if (firstTab) {
            // dispatch a click so the delegated handler activates it
            firstTab.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
        }
        
        // Setup buttons after a delay to ensure DOM is fully ready
        setTimeout(() => {
            setupButtons();
        }, 100);
    }
        
        // Check for hardware circuit data and load it
        loadHardwareCircuitData();
    }





    // Setup the dial parameters enable/disable toggle
    function setupDialToggle() {
        const toggle = document.getElementById('enable_dial_params');
        const dialFormEl = document.getElementById('dial-form');
        if (!toggle || !dialFormEl) return;

        const container = dialFormEl.querySelector('.dial-accordion') || dialFormEl;
        const numberInputs = Array.from(dialFormEl.querySelectorAll('input[type="number"]'));

        const setDisabledState = (enabled) => {
            if (enabled) {
                container.classList.remove('dial-params-disabled');
                numberInputs.forEach(i => i.disabled = false);
            } else {
                container.classList.add('dial-params-disabled');
                numberInputs.forEach(i => i.disabled = true);
            }
        };

        // initialize
        setDisabledState(toggle.checked);

        toggle.addEventListener('change', function() {
            setDisabledState(this.checked);
        });
    }

    // Load hardware circuit data from localStorage if available
    function loadHardwareCircuitData() {
        const hardwareData = localStorage.getItem('hardwareCircuitData');
        
        if (hardwareData) {
            try {
                const circuitData = JSON.parse(hardwareData);
                const cellboard = circuitData.cellboard;
                
                if (cellboard && typeof cellboard === 'object') {
                    console.log('Loading hardware circuit data:', cellboard);
                    
                    // Show notification that hardware circuit is being loaded
                    showHardwareLoadNotification();
                    
                    // Convert cellboard format to designer format and place components
                    setTimeout(() => {
                        const placedCount = loadCellboardToDesigner(cellboard);
                        // localStorage is cleared inside loadCellboardToDesigner only on success
                        if (placedCount === 0) {
                            console.warn('No components were successfully placed from hardware data');
                            localStorage.removeItem('hardwareCircuitData'); // Clear if no placement succeeded
                        }
                    }, 500); // Small delay to allow UI to initialize
                }
            } catch (error) {
                console.error('Error loading hardware circuit data:', error);
                localStorage.removeItem('hardwareCircuitData'); // Clear corrupted data
            }
        }
    }
    
    // Show notification that hardware circuit is being loaded
    function showHardwareLoadNotification() {
        showNotification('Loading circuit from Cell Board...', 'success', 'microchip');
    }
    
    // Show error notification
    function showErrorNotification(message) {
        showNotification(message, 'error', 'exclamation-triangle');
    }
    
    // Generic notification function
    function showNotification(message, type = 'info', icon = 'info-circle') {
        const colors = {
            success: '#28a745',
            error: '#dc3545', 
            warning: '#ffc107',
            info: '#17a2b8'
        };
        
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${colors[type] || colors.info};
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            z-index: 1000;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            max-width: 300px;
        `;
        notification.innerHTML = `<i class="fas fa-${icon} me-2"></i>${message}`;
        
        document.body.appendChild(notification);
        
        // Remove after 4 seconds for errors, 3 seconds for others
        const timeout = type === 'error' ? 4000 : 3000;
        setTimeout(() => {
            notification.remove();
        }, timeout);
    }
    
    // Clear all components without confirmation (for programmatic use)
    function clearAllComponents() {
        // Clear state
        state.placedComponents = [];
        
        // Clear connector system
        ConnectorManagerEEPROM.clearAll();
        
        // Clear visuals
        cells.forEach(cell => {
            removeComponentVisual(cell);
        });
        
        console.log('All components cleared programmatically');
    }
    
    // Test function to verify data transfer functionality
    window.testHardwareDataTransfer = function() {
        console.log('=== Testing Hardware Data Transfer ===');
        
        // Create mock cellboard data that simulates hardware output
        const mockCellboard = {
            'Promoter': [
                { gene: '1', strength: 'strong', x: '0', y: '0' },
                { gene: 'Gene 2', strength: 'norm', x: '2', y: '1' }
            ],
            'RBS': [
                { gene: '1', strength: 'norm', x: '1', y: '0' }
            ],
            'CDS': [
                { gene: '1', strength: 'weak', x: '2', y: '0' },
                { gene: '2', strength: 'strong', x: '3', y: '1' }
            ],
            'Terminator': [
                { gene: '1', strength: 'norm', x: '3', y: '0' }
            ]
        };
        
        console.log('1. Testing localStorage save/load format...');
        const testData = {
            cellboard: mockCellboard,
            timestamp: Date.now(),
            source: 'test_hardware'
        };
        
        // Test localStorage save
        localStorage.setItem('hardwareCircuitData', JSON.stringify(testData));
        console.log('✓ Data saved to localStorage');
        
        // Test data loading
        console.log('2. Testing loadCellboardToDesigner function...');
        const placedCount = loadCellboardToDesigner(mockCellboard);
        console.log(`✓ Placed ${placedCount} components`);
        
        // Test gene format handling
        console.log('3. Verifying gene format normalization...');
        state.placedComponents.forEach(comp => {
            console.log(`  Component: ${comp.type}, Gene: ${comp.gene}, Position: (${comp.x}, ${comp.y})`);
            if (!comp.gene.startsWith('Gene ')) {
                console.error(`✗ Gene format error: ${comp.gene} should start with 'Gene '`);
            } else {
                console.log(`  ✓ Gene format correct: ${comp.gene}`);
            }
        });
        
        // Test placement function usage
        console.log('4. Verifying placement integrity...');
        const cellsWithComponents = document.querySelectorAll('.cell.has-component');
        console.log(`  Visual components: ${cellsWithComponents.length}`);
        console.log(`  State components: ${state.placedComponents.length}`);
        
        if (cellsWithComponents.length === state.placedComponents.length) {
            console.log('  ✓ Visual and state components match');
        } else {
            console.error('  ✗ Mismatch between visual and state components');
        }
        
        // Test localStorage clearing after successful placement
        console.log('5. Testing localStorage cleanup...');
        const remainingData = localStorage.getItem('hardwareCircuitData');
        if (!remainingData) {
            console.log('  ✓ localStorage cleared after successful placement');
        } else {
            console.error('  ✗ localStorage not cleared properly');
        }
        
        console.log('=== Hardware Data Transfer Test Complete ===');
        return {
            placedCount,
            stateComponents: state.placedComponents.length,
            visualComponents: cellsWithComponents.length,
            localStorageCleared: !remainingData
        };
    };
    
    // Make test available globally for debugging
    window.debugDataTransfer = function() {
        console.log('Current state:', {
            placedComponents: state.placedComponents,
            currentComponent: state.currentComponent,
            currentGene: state.currentGene,
            currentStrength: state.currentStrength
        });
        
        console.log('Visual grid state:');
        document.querySelectorAll('.cell.has-component').forEach(cell => {
            console.log(`  Cell (${cell.dataset.x}, ${cell.dataset.y}): ${cell.textContent}`);
        });
    };
    
    // Convert cellboard format to designer format and place components
    function loadCellboardToDesigner(cellboard) {
        let successfulPlacements = 0;
        let totalComponents = 0;
        
        // Clear existing components first
        clearAllComponents();
        
        // Mapping of cellboard component types to designer component types
        const componentTypeMap = {
            'Promoter': 'Promoter',
            'RBS': 'RBS', 
            'CDS': 'CDS',
            'Terminator': 'Terminator',
            'Repressor Start': 'Repressor Start',
            'Repressor End': 'Repressor End',
            'Activator Start': 'Activator Start',
            'Activator End': 'Activator End'
        };
        
        try {
            // Process each component type from cellboard
            Object.entries(cellboard).forEach(([componentType, componentList]) => {
                if (Array.isArray(componentList)) {
                    componentList.forEach(comp => {
                        totalComponents++;
                        const designerType = componentTypeMap[componentType];
                        if (designerType) {
                            // Find the cell at the specified position
                            const cell = document.querySelector(`[data-x="${comp.x}"][data-y="${comp.y}"]`);
                            if (cell && cell.classList.contains('functional')) {
                                // Normalize gene format - ensure it's "Gene X" format
                                let geneIdentifier;
                                if (comp.gene && comp.gene.startsWith('Gene ')) {
                                    geneIdentifier = comp.gene; // Already in correct format
                                } else if (comp.gene && /^\d+$/.test(comp.gene.toString())) {
                                    geneIdentifier = `Gene ${comp.gene}`; // Convert "1" to "Gene 1"
                                } else {
                                    geneIdentifier = 'Gene 1'; // Default fallback
                                }
                                
                                // Set up state for placement
                                state.currentComponent = designerType;
                                state.currentGene = geneIdentifier.split(' ')[1]; // Extract number part
                                state.currentStrength = comp.strength || 'norm';
                                
                                // Use proper placement function to maintain invariants
                                placeComponent(cell);
                                successfulPlacements++;
                                
                                console.log('Placed hardware component:', {
                                    type: designerType,
                                    gene: geneIdentifier,
                                    strength: comp.strength || 'norm',
                                    x: comp.x,
                                    y: comp.y
                                });
                            } else {
                                console.warn(`Cannot place component at (${comp.x}, ${comp.y}): cell not found or not functional`);
                            }
                        } else {
                            console.warn(`Unknown component type: ${componentType}`);
                        }
                    });
                }
            });
            
            console.log(`Successfully loaded ${successfulPlacements}/${totalComponents} components from Cell Board`);
            
            // Only clear localStorage after successful placement
            if (successfulPlacements > 0) {
                localStorage.removeItem('hardwareCircuitData');
                console.log('Hardware circuit data cleared from localStorage after successful transfer');
            }
            
            // After placement, ensure UI reflects number of genes found
            try {
                const maxGene = state.placedComponents.reduce((max, c) => {
                    const n = parseInt((c.gene || 'Gene 1').toString().split(' ')[1]) || 1;
                    return Math.max(max, n);
                }, 1);
                ensureGenesUI(maxGene);
                ensureGeneParameterSections(maxGene);
            } catch (e) {
                console.warn('Error ensuring dynamic gene UI:', e);
            }

            return successfulPlacements;
            
        } catch (error) {
            console.error('Error loading hardware circuit data:', error);
            showErrorNotification('Failed to load some components from Cell Board');
            return successfulPlacements;
        }
    }

    // Create or reveal gene tabs and panels up to maxGene
    function ensureGenesUI(maxGene) {
        const tabsContainer = document.getElementById('gene-tabs');
        const componentsContainer = document.getElementById('gene-components');
        if (!tabsContainer || !componentsContainer) return;

        // find the template panel to clone (prefer the one with class template)
        const templatePanel = componentsContainer.querySelector('.gene-panel.template') || componentsContainer.querySelector('.gene-panel');
    for (let i = 1; i <= maxGene; i++) {
            // Create tab if missing
            if (!tabsContainer.querySelector(`.gene-tab[data-gene="${i}"]`)) {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'gene-tab';
                if (i === 1) btn.classList.add('active');
                btn.dataset.gene = String(i);
                btn.setAttribute('role', 'tab');
                btn.setAttribute('aria-selected', i === 1 ? 'true' : 'false');
                btn.textContent = `Gene ${i}`;
                // attach a direct handler so newly-created tabs work even if delegation missed
                btn.addEventListener('click', function(e) {
                    activateGeneTab(this);
                });
                tabsContainer.appendChild(btn);
            }

            // Create panel if missing
            if (!componentsContainer.querySelector(`.gene-panel[data-gene="${i}"]`)) {
                if (!templatePanel) continue;
                const clone = templatePanel.cloneNode(true);
                clone.classList.remove('template');
                // remove any 'active' class unless it's gene 1
                clone.classList.toggle('active', i === 1);
                clone.dataset.gene = String(i);
                // update internal components' data-gene attributes
                clone.querySelectorAll('.component').forEach(comp => {
                    comp.dataset.gene = String(i);
                    // update inner markup if any references to gene present (not common)
                });
                componentsContainer.appendChild(clone);
            }
        }

        // Re-attach gene tab handlers
        setupGeneTabs();
        // Re-attach component handlers for any newly cloned components
        setupComponents();
        // Update tab density (compact mode) when many genes exist
        updateGeneTabDensity();
    }

    // Helper to activate a gene tab element
    function activateGeneTab(tab) {
        if (!tab) return;
        // Deactivate all tabs and panels (also unset aria-selected)
            deactivateAllTabsAndPanels();
            activateTargetTab(tab);
        }

        function deactivateAllTabsAndPanels() {
            document.querySelectorAll('.gene-tab').forEach(t => { t.classList.remove('active'); t.setAttribute('aria-selected', 'false'); });
            document.querySelectorAll('.gene-panel').forEach(p => p.classList.remove('active'));
        }

        function activateTargetTab(tab) {
            tab.classList.add('active');
            tab.setAttribute('aria-selected', 'true');
            const gene = tab.dataset.gene;
            state.currentGene = gene;
            const targetPanel = document.querySelector(`.gene-panel[data-gene="${gene}"]`);
            if (targetPanel) targetPanel.classList.add('active');
    }

    // Add gene button wiring
    function setupAddGeneButton() {
        const addBtn = document.getElementById('add-gene-btn');
        if (!addBtn) return;
        addBtn.addEventListener('click', function() {
            // determine current highest gene
            const existingTabs = Array.from(document.querySelectorAll('.gene-tab')).map(b => parseInt(b.dataset.gene || '1'));
            const max = existingTabs.length ? Math.max(...existingTabs) : 1;
            const next = max + 1;
            ensureGenesUI(next);
            ensureGeneParameterSections(next);
            // activate the new tab
            const newTab = document.querySelector(`.gene-tab[data-gene="${next}"]`);
            if (newTab) {
                // dispatch a bubbling click so delegated listener handles it reliably
                newTab.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true }));
                // smooth scroll so the tab is visible when many tabs exist
                try { newTab.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' }); } catch (e) {}
                // adjust tab density after adding
                updateGeneTabDensity();
            }
        });
    }

    // Remove gene button wiring
    function setupRemoveGeneButton() {
        const removeBtn = document.getElementById('remove-gene-btn');
        if (!removeBtn) return;
        removeBtn.addEventListener('click', function() {
            // Find highest gene number
            const tabs = Array.from(document.querySelectorAll('.gene-tab')).map(b => parseInt(b.dataset.gene || '1')).filter(n => !isNaN(n));
            if (tabs.length <= 1) return; // nothing to remove (keep gene 1)
            const max = Math.max(...tabs);
            if (max <= 1) return;

            // Remove UI: tab, panel, and parameter section
            const tab = document.querySelector(`.gene-tab[data-gene="${max}"]`);
            const panel = document.querySelector(`.gene-panel[data-gene="${max}"]`);
            const paramSummary = Array.from(document.querySelectorAll('.dial-accordion-item')).find(det => {
                const s = det.querySelector('.dial-accordion-header');
                return s && s.textContent.trim().match(new RegExp(`Gene\\s*${max}`));
            });

            // Reassign placed components for this gene to Gene 1 to avoid losing them
            state.placedComponents.forEach(c => {
                const geneNum = parseInt((c.gene || 'Gene 1').split(' ')[1]) || 1;
                if (geneNum === max) {
                    c.gene = 'Gene 1';
                }
            });

            // Update visuals on board where necessary
            document.querySelectorAll('.cell.has-component').forEach(cell => {
                const text = (cell.textContent || '').trim();
                const m = text.match(/^(\d+):/);
                if (m && parseInt(m[1]) === max) {
                    // change displayed gene number to 1
                    const rest = text.replace(/^\d+:/, '1:');
                    cell.firstChild && (cell.firstChild.textContent = rest);
                    cell.textContent = rest; // simpler approach
                }
            });

            if (tab) tab.remove();
            if (panel) panel.remove();
            if (paramSummary) paramSummary.remove();

            // Activate the previous highest tab
            const remaining = Array.from(document.querySelectorAll('.gene-tab')).map(b => parseInt(b.dataset.gene || '1'));
            const newMax = remaining.length ? Math.max(...remaining) : 1;
            const newTab = document.querySelector(`.gene-tab[data-gene="${newMax}"]`);
            if (newTab) activateGeneTab(newTab);
            // update compact/normal density after removal
            updateGeneTabDensity();
        });
    }

    // Reduce tab padding/min-width when many genes are present so layout doesn't expand
    function updateGeneTabDensity() {
        const wrapper = document.querySelector('.gene-tabs-wrapper');
        if (!wrapper) return;
        const tabCount = document.querySelectorAll('.gene-tab').length;
        // Toggle a class that makes tabs more compact when there are many of them
        if (tabCount > 10) {
            wrapper.classList.add('many-genes');
        } else {
            wrapper.classList.remove('many-genes');
        }
    }

    // Add parameter sections (accordion details) for genes beyond the static ones
    function ensureGeneParameterSections(maxGene) {
        const dialFormEl = document.getElementById('dial-form');
        if (!dialFormEl) return;
        const accordion = dialFormEl.querySelector('.dial-accordion');
        if (!accordion) return;

        // Helper to create a details block for a gene
        function createGeneDetails(n) {
            const d = document.createElement('details');
            d.className = 'dial-accordion-item';
            const s = document.createElement('summary');
            s.className = 'dial-accordion-header';
            s.textContent = `Gene ${n} Components`;
            d.appendChild(s);

            const body = document.createElement('div');
            body.className = 'dial-accordion-body';
            const grid = document.createElement('div');
            grid.className = 'dial-grid';

            const fields = [
                ['Promoter Strength', `promoter${n}_strength`, '1.0', '0.1', '5.0', '0.1'],
                ['RBS Efficiency', `rbs${n}_efficiency`, '1.0', '0.1', '2.0', '0.1'],
                ['CDS Translation Rate', `cds${n}_translation_rate`, '5.0', '1.0', '20.0', '0.5'],
                ['CDS Degradation Rate', `cds${n}_degradation_rate`, '0.1', '0.01', '1.0', '0.01'],
                ['Terminator Eff', `terminator${n}_efficiency`, '0.99', '0.1', '1.0', '0.01'],
                ['Initial Protein Conc', `protein${n}_initial_conc`, '0.1', '0.0', '2.0', '0.05']
            ];

            fields.forEach(([label, name, value, min, max, step]) => {
                const lab = document.createElement('label');
                lab.setAttribute('for', name);
                lab.textContent = label + ':';
                const inp = document.createElement('input');
                inp.type = 'number';
                inp.id = name;
                inp.name = name;
                inp.value = value;
                inp.min = min;
                inp.max = max;
                inp.step = step;
                grid.appendChild(lab);
                grid.appendChild(inp);
            });

            body.appendChild(grid);
            d.appendChild(body);
            return d;
        }

        // Determine existing gene detail numbers
        const existing = Array.from(accordion.querySelectorAll('.dial-accordion-item')).map(det => {
            const summary = det.querySelector('.dial-accordion-header');
            if (!summary) return 0;
            const m = summary.textContent.match(/Gene\s*(\d+)/i);
            return m ? parseInt(m[1]) : 0;
        }).filter(n => n > 0);
        const maxExisting = existing.length ? Math.max(...existing) : 1;

        for (let i = 1; i <= maxGene; i++) {
            if (i <= maxExisting) continue; // already present
            const details = createGeneDetails(i);
            accordion.appendChild(details);
        }
    }

    // Gene tab functionality
    function setupGeneTabs() {
        const tabsContainer = document.getElementById('gene-tabs');
        if (!tabsContainer) return;
        if (tabsContainer._geneListenerAttached) return; // idempotent

        tabsContainer.addEventListener('click', function(e) {
            const tab = e.target.closest('.gene-tab');
            if (!tab || !tabsContainer.contains(tab)) return;

            // Deactivate all tabs and panels
            document.querySelectorAll('.gene-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.gene-panel').forEach(p => p.classList.remove('active'));

            // Activate clicked tab
            tab.classList.add('active');
            const gene = tab.dataset.gene;
            state.currentGene = gene;

            const targetPanel = document.querySelector(`.gene-panel[data-gene="${gene}"]`);
            if (targetPanel) targetPanel.classList.add('active');
        });

        tabsContainer._geneListenerAttached = true;
    }

    // Removed duplicate setupComponents function - using the main one
                
                // Visual feedback
                this.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    this.style.transform = '';
                }, 150);
            });

            // Strength selection
            const strengthOptions = comp.querySelectorAll('.strength-option');
            strengthOptions.forEach(option => {
                option.addEventListener('click', function(e) {
                    e.stopPropagation();
                    state.currentStrength = this.dataset.strength;
                    this.parentElement.style.display = 'none';
                    
                    // Visual feedback
                    const component = this.closest('.component');
                    component.style.boxShadow = `0 0 0 3px ${getStrengthColor(state.currentStrength)}`;
                    setTimeout(() => {
                        component.style.boxShadow = '';
                    }, 1000);
                });
            });
        });
        // update the global components NodeList reference for other functions
        // (optional) but keep original variable to avoid undefined elsewhere
        // components = document.querySelectorAll('.component'); // don't overwrite const
    }

    // Cell interactions
    function setupCells() {
        cells.forEach(cell => {
            // Click to place component
            cell.addEventListener('click', function() {
                if (this.classList.contains('functional') && state.currentComponent && !this.classList.contains('has-component')) {
                    placeComponent(this);
                }
            });

            // Right-click to remove component
            cell.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                if (this.classList.contains('has-component')) {
                    removeComponent(this);
                }
            });
        });
    }

    // Setup drag and drop functionality
    function setupDragAndDrop() {
        // Dragstart for components
        components.forEach(comp => {
            comp.addEventListener('dragstart', function(e) {
                state.isDragging = true;
                state.draggedElement = this;
                state.currentComponent = this.dataset.component;
                state.currentGene = this.dataset.gene;
                
                // Set drag image
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    component: this.dataset.component,
                    gene: this.dataset.gene
                }));
                
                // Visual feedback
                this.style.opacity = '0.5';
            });

            comp.addEventListener('dragend', function() {
                state.isDragging = false;
                state.draggedElement = null;
                this.style.opacity = '';
            });
        });

        // Drop zones (cells)
        cells.forEach(cell => {
            if (cell.classList.contains('functional')) {
                cell.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.dataTransfer.dropEffect = 'copy';
                    if (!this.classList.contains('has-component')) {
                        this.style.backgroundColor = 'rgba(0, 156, 77, 0.2)';
                        this.style.borderColor = 'var(--primary)';
                    }
                });

                cell.addEventListener('dragleave', function() {
                    if (!this.classList.contains('has-component')) {
                        this.style.backgroundColor = '';
                        this.style.borderColor = '';
                    }
                });

                cell.addEventListener('drop', function(e) {
                    e.preventDefault();
                    if (!this.classList.contains('has-component')) {
                        this.style.backgroundColor = '';
                        this.style.borderColor = '';
                        
                        if (state.currentComponent) {
                            placeComponent(this);
                        }
                    }
                });
            }
        });
    }

    // Global reset parameters function (accessible by onclick)
    window.resetParameters = function() {
        console.log('Reset parameters called');
        
        // Reset all parameter inputs to their default values
        const parameterInputs = document.querySelectorAll('#parameter-panel input[type="number"], #parameter-panel input[type="range"]');
        parameterInputs.forEach(input => {
            if (input.dataset.default) {
                input.value = input.dataset.default;
            } else {
                // Set common defaults based on parameter type
                if (input.id.includes('strength') || input.id.includes('rate')) {
                    input.value = 1.0;
                } else if (input.id.includes('degradation')) {
                    input.value = 0.1;
                } else {
                    input.value = input.min || 0;
                }
            }
            
            // Trigger change event to update any linked elements
            input.dispatchEvent(new Event('change', { bubbles: true }));
        });
        
        console.log('Parameters reset to defaults');
    };

    // Button event handlers
    function setupButtons() {
        // Re-query buttons to ensure we have current references
        const currentSimulateBtn = document.getElementById('simulate-btn');
        const currentClearBtn = document.getElementById('clear-btn');
        const exportBtn = document.getElementById('export-btn');
        const helpBtn = document.getElementById('help-btn');
        
        console.log('Setting up buttons:', {
            simulate: !!currentSimulateBtn,
            clear: !!currentClearBtn,
            export: !!exportBtn,
            help: !!helpBtn
        });

        if (currentSimulateBtn) {
            // Remove any existing listeners to prevent duplicates
            currentSimulateBtn.replaceWith(currentSimulateBtn.cloneNode(true));
            const newSimulateBtn = document.getElementById('simulate-btn');
            newSimulateBtn.addEventListener('click', function() {
                console.log('Simulate button clicked!');
                runSimulation();
            });
            console.log('Simulate button listener attached');
        } else {
            console.warn('Simulate button not found');
        }

        if (currentClearBtn) {
            // Remove any existing listeners to prevent duplicates
            currentClearBtn.replaceWith(currentClearBtn.cloneNode(true));
            const newClearBtn = document.getElementById('clear-btn');
            newClearBtn.addEventListener('click', function() {
                console.log('Clear button clicked!');
                clearBoard();
            });
            console.log('Clear button listener attached');
        } else {
            console.warn('Clear button not found');
        }

        if (exportBtn) {
            exportBtn.addEventListener('click', exportProject);
        }

        if (helpBtn) {
            helpBtn.addEventListener('click', showHelp);
        }

        // Close strength menus when clicking outside
        document.addEventListener('click', function(e) {
            const isHamburgerClick = e.target.closest('.hamburger-menu') || e.target.closest('.parameters-panel');
            if (!e.target.closest('.component') && !e.target.closest('.strength-menu') && !isHamburgerClick) {
                document.querySelectorAll('.strength-menu').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
        });
    }

    // Place component on board
    function placeComponent(cell) {
        if (!state.currentComponent) {
            console.error('No component selected. currentComponent is:', state.currentComponent);
            return;
        }

        const x = cell.dataset.x;
        const y = cell.dataset.y;

        // Remove existing component from this cell
        const existingIndex = state.placedComponents.findIndex(c => c.x === x && c.y === y);
        if (existingIndex >= 0) {
            state.placedComponents.splice(existingIndex, 1);
            // Remove from connector system
            ConnectorManagerEEPROM.removeComponent(cell);
            removeComponentVisual(cell);
        }

        // Auto-increment component number based on type (like dial mode)
        const baseType = state.currentComponent.toLowerCase().replace(' ', '_');
        if (!state.componentCounts[baseType]) {
            state.componentCounts[baseType] = 1;
        } else {
            state.componentCounts[baseType]++;
        }
        
        console.log(`Creating component: type=${state.currentComponent}, number=${state.componentCounts[baseType]}, strength=${state.currentStrength}`);

        // Create new component (dial mode format)
        const component = {
            type: state.currentComponent,
            number: state.componentCounts[baseType], // Component number like dial mode
            strength: state.currentStrength || 'norm',
            x: x,
            y: y,
            id: Date.now() + Math.random(), // Unique ID like dial mode
            customName: null, // For component renaming
            parameters: {} // For component parameters
        };

        state.placedComponents.push(component);
        updateCellDisplay(cell.dataset.x, cell.dataset.y, component.type, component.number, component.customName);

        // Add to connector system if it's a regulatory component
        if (['Repressor Start', 'Repressor End', 'Activator Start', 'Activator End'].includes(component.type)) {
            ConnectorManagerEEPROM.addComponent(component, cell);
        }

        // Animation feedback
        cell.classList.add('placed');
        setTimeout(() => {
            cell.classList.remove('placed');
        }, 300);

        console.log('Component placed:', component);
        console.log('Total components:', state.placedComponents.length);
    }

    // Remove component from board
    function removeComponent(cell) {
        const x = cell.dataset.x;
        const y = cell.dataset.y;

        const index = state.placedComponents.findIndex(c => c.x === x && c.y === y);
        if (index >= 0) {
            state.placedComponents.splice(index, 1);
            // Remove from connector system
            ConnectorManagerEEPROM.removeComponent(cell);
            removeComponentVisual(cell);
            console.log('Component removed from:', x, y);
        }
    }

    // Add dial mode's updateCellDisplay function
    function updateCellDisplay(x, y, componentType, componentNumber, customName = null) {
        const cell = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        if (!cell) return;
        
        // Clear previous content
        cell.innerHTML = '';
        cell.classList.add('has-component');
        
        // Find the component in our data to get its custom name
        let component = null;
        component = state.placedComponents.find(comp => comp.x == x && comp.y == y);
        
        // Create component display
        const display = document.createElement('div');
        display.className = 'placed-component';
        
        // Use custom name if available, otherwise show component type with number
        const displayName = (component && component.customName) || `${componentType} #${componentNumber}`;
        display.textContent = displayName;
        display.title = `${componentType} #${componentNumber} - Click to edit parameters`;
        
        // Add component-specific styling
        display.classList.add(`component-${componentType.toLowerCase().replace(' ', '-')}`);
        
        // Add regulator types (same as dial mode)
        const REGULATOR_TYPES = ['Repressor Start', 'Repressor End', 'Activator Start', 'Activator End', 
                                'Inducer Start', 'Inducer End', 'Inhibitor Start', 'Inhibitor End'];
        
        // Add click event for parameter editing (exclude regulators)
        if (!REGULATOR_TYPES.includes(componentType)) {
            display.addEventListener('click', function(e) {
                e.stopPropagation();
                showComponentParameterModal(x, y, componentType, componentNumber, component);
            });
            
            // Add visual indicator that component is clickable for parameters
            display.classList.add('has-parameters');
            display.title += ' (Click to edit parameters & rename)';
        }
        
        cell.appendChild(display);
    }

    // Add dial mode's parameter modal functionality
    function showComponentParameterModal(x, y, componentType, componentNumber, component) {
        // Create modal overlay
        const overlay = document.createElement('div');
        overlay.className = 'parameter-modal-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        `;
        
        // Create modal content
        const modal = document.createElement('div');
        modal.className = 'parameter-modal';
        modal.style.cssText = `
            background: rgba(32, 44, 45, 0.98);
            border: 1px solid rgba(178, 243, 95, 0.3);
            border-radius: 12px;
            padding: 0;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            backdrop-filter: blur(20px);
        `;
        
        // Modal header
        const header = document.createElement('div');
        header.className = 'parameter-modal-header';
        header.style.cssText = `
            background: rgba(27, 38, 39, 0.95);
            color: #ffffff;
            padding: 20px;
            border-bottom: 1px solid rgba(178, 243, 95, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        `;
        
        const title = document.createElement('h3');
        title.textContent = `${component?.customName || componentType + ' #' + componentNumber} Parameters`;
        title.style.cssText = `margin: 0; font-size: 1.3rem;`;
        
        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = '×';
        closeBtn.style.cssText = `
            background: none;
            border: none;
            color: #ffffff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
        `;
        closeBtn.onclick = () => overlay.remove();
        
        header.appendChild(title);
        header.appendChild(closeBtn);
        
        // Modal body with parameters
        const body = document.createElement('div');
        body.className = 'parameter-modal-body';
        body.style.cssText = `
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        `;
        
        // Add component name/rename field first
        const nameGroup = document.createElement('div');
        nameGroup.style.cssText = `margin-bottom: 20px;`;
        
        const nameLabel = document.createElement('label');
        nameLabel.textContent = 'Component Name:';
        nameLabel.style.cssText = `
            display: block;
            color: #ffffff;
            font-weight: 600;
            margin-bottom: 8px;
        `;
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.placeholder = `${componentType} #${componentNumber}`;
        nameInput.value = component?.customName || '';
        nameInput.style.cssText = `
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(178, 243, 95, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            font-size: 14px;
        `;
        
        // Add real-time name update
        nameInput.addEventListener('input', function() {
            if (component) {
                component.customName = this.value.trim() || null;
                // Update the modal title in real-time
                title.textContent = `${this.value.trim() || componentType + ' #' + componentNumber} Parameters`;
                console.log(`Renamed component to: ${this.value.trim()}`);
            }
        });
        
        nameGroup.appendChild(nameLabel);
        nameGroup.appendChild(nameInput);
        body.appendChild(nameGroup);
        
        // Add separator
        const separator = document.createElement('hr');
        separator.style.cssText = `
            border: none;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin: 15px 0;
        `;
        body.appendChild(separator);
        
        // Get parameters for this component
        const parameters = getComponentParameters(componentType, componentNumber);
        
        parameters.forEach(param => {
            const paramGroup = document.createElement('div');
            paramGroup.style.cssText = `margin-bottom: 15px;`;
            
            const label = document.createElement('label');
            label.textContent = param.label;
            label.style.cssText = `
                display: block;
                color: #ffffff;
                font-weight: 600;
                margin-bottom: 8px;
            `;
            
            const input = document.createElement('input');
            input.type = 'number';
            input.min = param.min;
            input.max = param.max;
            input.step = param.step;
            // Load existing value if available, otherwise use default
            const existingValue = component?.parameters?.[param.id];
            input.value = existingValue !== undefined ? existingValue : param.defaultValue;
            input.style.cssText = `
                width: 100%;
                padding: 10px;
                border: 1px solid rgba(178, 243, 95, 0.3);
                border-radius: 6px;
                background: rgba(255, 255, 255, 0.1);
                color: #ffffff;
                font-size: 14px;
            `;
            
            if (param.title) {
                input.title = param.title;
            }
            
            // Add real-time update
            input.addEventListener('input', function() {
                // Update component data
                if (component) {
                    if (!component.parameters) component.parameters = {};
                    component.parameters[param.id] = parseFloat(this.value);
                }
                console.log(`Updated ${param.id} to ${this.value} for component at (${x}, ${y})`);
            });
            
            paramGroup.appendChild(label);
            paramGroup.appendChild(input);
            body.appendChild(paramGroup);
        });
        
        // Modal footer
        const footer = document.createElement('div');
        footer.style.cssText = `
            padding: 20px;
            border-top: 1px solid rgba(178, 243, 95, 0.2);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        `;
        
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.cssText = `
            padding: 10px 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            cursor: pointer;
        `;
        cancelBtn.onclick = () => overlay.remove();
        
        const applyBtn = document.createElement('button');
        applyBtn.textContent = 'Apply';
        applyBtn.style.cssText = `
            padding: 10px 20px;
            border: 1px solid rgba(178, 243, 95, 0.5);
            border-radius: 6px;
            background: rgba(178, 243, 95, 0.2);
            color: #ffffff;
            cursor: pointer;
        `;
        applyBtn.onclick = () => {
            // Parameters and name are already updated in real-time
            // Update the visual display to reflect any name changes
            updateCellDisplay(x, y, componentType, componentNumber, component?.customName);
            overlay.remove();
            console.log(`Applied parameters and name for ${componentType} at (${x}, ${y})`);
        };
        
        footer.appendChild(cancelBtn);
        footer.appendChild(applyBtn);
        
        // Assemble modal
        modal.appendChild(header);
        modal.appendChild(body);
        modal.appendChild(footer);
        overlay.appendChild(modal);
        
        // Add to page
        document.body.appendChild(overlay);
        
        // Close on overlay click
        overlay.addEventListener('click', function(e) {
            if (e.target === overlay) {
                overlay.remove();
            }
        });
    }

    // Add dial mode's getComponentParameters function
    function getComponentParameters(componentType, componentNumber) {
        // Skip parameters for regulator components
        const REGULATOR_TYPES = ['Repressor Start', 'Repressor End', 'Activator Start', 'Activator End', 
                                'Inducer Start', 'Inducer End', 'Inhibitor Start', 'Inhibitor End'];
        if (REGULATOR_TYPES.includes(componentType)) {
            return [];
        }
        
        const num = componentNumber;
        
        const commonParams = {
            'Promoter': [
                {
                    id: `promoter${num}_strength`,
                    label: 'Promoter Strength:',
                    min: 0.1,
                    max: 5.0,
                    step: 0.1,
                    defaultValue: 1.0
                }
            ],
            'RBS': [
                {
                    id: `rbs${num}_efficiency`,
                    label: 'RBS Efficiency:',
                    min: 0.1,
                    max: 2.0,
                    step: 0.1,
                    defaultValue: 1.0
                }
            ],
            'CDS': [
                {
                    id: `cds${num}_translation_rate`,
                    label: 'CDS Translation Rate:',
                    min: 1.0,
                    max: 20.0,
                    step: 0.5,
                    defaultValue: 5.0
                },
                {
                    id: `cds${num}_degradation_rate`,
                    label: 'CDS Degradation Rate:',
                    min: 0.01,
                    max: 1.0,
                    step: 0.01,
                    defaultValue: 0.1
                },
                {
                    id: `protein${num}_initial_conc`,
                    label: 'Initial Protein Conc:',
                    min: 0.0,
                    max: 2.0,
                    step: 0.05,
                    defaultValue: 0.1,
                    title: 'Starting concentration (µM) - affects oscillation dynamics'
                }
            ],
            'Terminator': [
                {
                    id: `terminator${num}_efficiency`,
                    label: 'Terminator Efficiency:',
                    min: 0.1,
                    max: 1.0,
                    step: 0.01,
                    defaultValue: 0.99
                }
            ]
        };
        
        return commonParams[componentType] || [];
    }

    // Update cell visual appearance
    function updateCellVisual(cell, component) {
        const colors = {
            'Promoter': '#FF6B6B',
            'Terminator': '#4ECDC4',
            'RBS': '#FFD166',
            'CDS': '#06D6A0',
            'Repressor Start': '#A78BFA',
            'Repressor End': '#7E22CE',
            'Activator Start': '#3B82F6',
            'Activator End': '#1E40AF'
        };

        // Clear existing content
        cell.innerHTML = '';
        
        // Set visual properties
        cell.style.backgroundColor = colors[component.type] || '#999';
        cell.style.color = 'white';
        cell.style.fontWeight = '600';
        cell.classList.add('has-component');

        // Mark cell as a node for jsPlumb
        cell.classList.add('component-node');
        cell.dataset.component = component.type;
        cell.dataset.gene = component.gene;



        // Create component display
        const geneNum = component.gene.split(' ')[1];
        const compAbbr = getComponentAbbreviation(component.type);
        cell.textContent = `${geneNum}:${compAbbr}`;

        // Add strength indicator
        const strengthDot = document.createElement('div');
        strengthDot.className = `strength-dot strength-${component.strength}`;
        strengthDot.style.backgroundColor = getStrengthColor(component.strength);
        cell.appendChild(strengthDot);
    }

    // Remove component visual
    function removeComponentVisual(cell) {
        cell.style.backgroundColor = '';
        cell.style.color = '';
        cell.style.fontWeight = '';
        cell.textContent = '';
        cell.classList.remove('has-component');
        
        // Remove jsPlumb marker and attributes
        cell.classList.remove('component-node');
        delete cell.dataset.component;
        delete cell.dataset.gene;

        const dot = cell.querySelector('.strength-dot');
        if (dot) {
            dot.remove();
        }
    }

    // Get component abbreviation
    function getComponentAbbreviation(type) {
        const abbreviations = {
            'Promoter': 'P',
            'Terminator': 'T',
            'RBS': 'R',
            'CDS': 'C',
            'Repressor Start': 'Rs',
            'Repressor End': 'Re',
            'Activator Start': 'As',
            'Activator End': 'Ae'
        };
        return abbreviations[type] || type.charAt(0);
    }

    // Get strength color
    function getStrengthColor(strength) {
        const colors = {
            'weak': '#fca5a5',
            'norm': '#fcd34d',
            'strong': '#86efac'
        };
        return colors[strength] || '#fcd34d';
    }

    // Run simulation
    async function runSimulation() {
        console.log('=== RUN SIMULATION CALLED ===');
        
        if (!simulateBtn) {
            console.error('Simulate button not found!');
            return;
        }

        // Disable button and show loading
        simulateBtn.disabled = true;
        simulateBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Running...';
        
        // Clear previous errors
        if (errorDisplay) {
            errorDisplay.style.display = 'none';
            errorDisplay.textContent = '';
        }

        // Show loading in plot container
        if (plotContainer) {
            plotContainer.innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p>Simulating genetic circuit dynamics...</p>
                </div>
            `;
        }

        try {
            // Always sync from DOM first - this handles all existing components
            const domComponents = document.querySelectorAll('.placed-component');
            console.log(`Found ${domComponents.length} visual components on board`);
            
            // Clear state and rebuild from DOM
            state.placedComponents = [];
            state.componentCounts = {};
            
            domComponents.forEach((el, i) => {
                const cell = el.parentElement;
                const componentType = el.dataset.component || el.textContent.split(' ')[0] || 'Unknown';
                
                // Auto-increment component number based on type
                const baseType = componentType.toLowerCase().replace(' ', '_');
                if (!state.componentCounts[baseType]) {
                    state.componentCounts[baseType] = 1;
                } else {
                    state.componentCounts[baseType]++;
                }
                
                const component = {
                    type: componentType,
                    number: state.componentCounts[baseType],
                    strength: el.dataset.strength || 'norm',
                    x: cell.dataset.x,
                    y: cell.dataset.y,
                    id: Date.now() + Math.random() + i,
                    customName: el.textContent,
                    parameters: {}
                };
                
                state.placedComponents.push(component);
                console.log(`Synced component ${i+1}: ${component.type} "${component.customName}" at (${component.x}, ${component.y})`);
            });
            
            console.log(`Total components synced: ${state.placedComponents.length}`);
            
            // Check if we have any components now
            if (state.placedComponents.length === 0) {
                throw new Error('No components placed on the board. Please place some components first.');
            }

            // Prepare cellboard data (dial mode format)
            const cellboard = {};
            state.placedComponents.forEach(comp => {
                if (!cellboard[comp.type]) {
                    cellboard[comp.type] = [];
                }
                cellboard[comp.type].push({
                    x: comp.x,
                    y: comp.y,
                    type: comp.type,
                    strength: comp.strength || 'norm',
                    id: comp.id,
                    number: comp.number // Component number like dial mode
                });
            });

            console.log('Prepared cellboard data (dial mode format):', cellboard);

            // Prepare request data
            const requestData = { cellboard: cellboard };

            // Add dial data if in dial mode AND the user enabled parameter overrides
            if (dialForm) {
                const toggle = document.getElementById('enable_dial_params');
                const includeDial = toggle ? toggle.checked : true;
                // Tell server explicitly whether to apply dial overrides
                requestData.apply_dial = !!includeDial;
                if (includeDial) {
                    const dialData = {};
                    
                    // Collect global parameters from dial form
                    const inputs = dialForm.querySelectorAll('input[type="number"]:not([disabled])');
                    console.log(`Collecting ${inputs.length} global parameter inputs`);
                    inputs.forEach(input => {
                        const value = parseFloat(input.value) || 0;
                        dialData[input.name] = value;
                        console.log(`  ${input.name}: ${value}`);
                    });
                    
                    // Collect component-specific parameters from placed components
                    state.placedComponents.forEach(comp => {
                        if (comp.parameters) {
                            Object.entries(comp.parameters).forEach(([key, value]) => {
                                dialData[key] = value;
                                console.log(`  Component parameter ${key}: ${value}`);
                            });
                        }
                    });
                    
                    requestData.dial = dialData;
                    console.log('All dial parameters collected:', dialData);
                }
                // if includeDial is false, we explicitly set apply_dial=false and omit dial
            } else {
                console.log('No dial form found - using default parameters');
                requestData.apply_dial = false;
            }

            // Debug: show whether dial overrides will be applied and the full payload
            console.log('Sending simulation request. apply_dial:', requestData.apply_dial, 'payload:', requestData);

            // Send simulation request
            const response = await fetch('/simulate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestData)
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.message || `Server error: ${response.status}`);
            }

            const result = await response.json();
            console.log('Simulation result:', result);

            if (result.status === 'success') {
                // Display results
                if (result.plot && plotContainer) {
                    plotContainer.innerHTML = `
                        <img src="data:image/png;base64,${result.plot}" 
                             alt="Simulation Results" 
                             class="plot-image">
                    `;
                } else if (plotContainer) {
                    plotContainer.innerHTML = '<p class="text-center">Simulation completed successfully</p>';
                }

                // Add animation
                if (plotContainer) {
                    plotContainer.classList.add('placed');
                    setTimeout(() => {
                        plotContainer.classList.remove('placed');
                    }, 300);
                }

                // Populate ontology analysis
                populateOntologyAnalysis(result);
                
                // Log detailed results
                if (result.circuits) {
                    console.log('Detected circuits:', result.circuits);
                }
                if (result.regulations) {
                    console.log('Regulatory networks:', result.regulations);
                }
                if (result.warnings && result.warnings.length > 0) {
                    console.warn('Simulation warnings:', result.warnings);
                }

            } else {
                throw new Error(result.message || 'Unknown simulation error');
            }

        } catch (error) {
            console.error('Simulation failed:', error);
            
            // Display error
            if (errorDisplay) {
                errorDisplay.textContent = `Error: ${error.message}`;
                errorDisplay.style.display = 'block';
            }

            // Show error in plot container
            if (plotContainer) {
                plotContainer.innerHTML = `
                    <div class="loading">
                        <i class="fas fa-exclamation-triangle" style="color: var(--error); font-size: 2rem;"></i>
                        <p>Simulation failed</p>
                        <small class="text-muted">${error.message}</small>
                    </div>
                `;
            }

        } finally {
            // Re-enable button
            simulateBtn.disabled = false;
            simulateBtn.innerHTML = '<i class="fas fa-play me-2"></i>Run Simulation';
        }
    }

    // Clear board
    function clearBoard() {
        if (state.placedComponents.length === 0) return;

        if (confirm('Are you sure you want to clear the design board?')) {
            // Clear state
            state.placedComponents = [];

            // Clear visuals
            cells.forEach(cell => {
                removeComponentVisual(cell);
            });

            // Reset plot container
            if (plotContainer) {
                plotContainer.innerHTML = `
                    <div class="loading">
                        <i class="fas fa-dna" style="color: var(--primary); font-size: 2rem;"></i>
                        <p>Design your circuit and run simulation</p>
                    </div>
                `;
            }

            // Clear errors
            if (errorDisplay) {
                errorDisplay.style.display = 'none';
            }

            console.log('Board cleared');
        }
    }

    // Show help
    function showHelp() {
        const helpText = `
How to use the Genetic Circuit Designer:

1. Select a gene tab (1, 2, or 3)
2. Click a component to select it
3. Click the component again to choose strength (weak/normal/strong)
4. Drag or click to place components on the board
5. Right-click on placed components to remove them
6. Use the Run Simulation button to analyze your circuit
7. Check the results for circuit dynamics and warnings

Components:
• Promoter: Initiates transcription
• RBS: Ribosome binding site for translation
• CDS: Coding sequence (protein output)
• Terminator: Stops transcription
• Repressor Start/End: Inhibits expression
• Activator Start/End: Enhances expression

Tips:
• Place components in logical order (Promoter → RBS → CDS → Terminator)
• Use regulatory elements to create complex networks
• Experiment with different strengths for varied dynamics
        `;
        
        alert(helpText);
    }

    // Ontology Analysis Population
    function populateOntologyAnalysis(result) {
        const analysisSection = document.getElementById('ontology-analysis');
        
        if (!analysisSection) return;
        
        // Show the analysis section
        analysisSection.style.display = 'block';
        
        const circuits = result.circuits || [];
        const regulations = result.regulations || [];
        const warnings = result.warnings || [];
        const errors = result.errors || [];
        
        // Calculate metrics
        const validCircuits = circuits.filter(c => c.components && c.components.length > 0 && (!c.fallback_by_cds || Object.keys(c.fallback_by_cds).length === 0));
        const incompleteCircuits = circuits.filter(c => c.fallback_by_cds && Object.keys(c.fallback_by_cds).length > 0);
        const extraComponents = circuits.reduce((acc, c) => acc + (c.extras ? c.extras.length : 0), 0);
        const regulatoryLinks = regulations.length;
        const unpairedRegs = result.unpaired_regulators || [];
        
        // Update status overview
        updateStatusOverview(validCircuits.length, incompleteCircuits.length, extraComponents, regulatoryLinks);
        
        // Populate detailed sections
        populateValidCircuits(validCircuits);
        populateIncompleteCircuits(circuits);
        populateUnpairedRegulators(unpairedRegs);
        populateRegulatoryNetworks(regulations);
        populateEquationDisplay(result);
        populateCircuitIssues(warnings, errors);
        populateExtraComponents(circuits);
        populateComponentAnalysis(circuits);
        
        // Add animation
        analysisSection.classList.add('placed');
        setTimeout(() => {
            analysisSection.classList.remove('placed');
        }, 300);
    }
    
    function updateStatusOverview(valid, incomplete, extra, regulatory) {
        document.getElementById('valid-circuits').textContent = valid;
        document.getElementById('incomplete-circuits').textContent = incomplete;
        document.getElementById('extra-components').textContent = extra;
        document.getElementById('regulatory-links').textContent = regulatory;
    }
    
    function populateIncompleteCircuits(circuits) {
        const container = document.getElementById('incomplete-circuits-list');
        
        // Filter for circuits with fallbacks
        const incompleteCircuits = circuits.filter(circuit => circuit.fallback_by_cds && Object.keys(circuit.fallback_by_cds).length > 0);
        
        if (incompleteCircuits.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-exclamation-triangle text-muted"></i>
                    <p>No incomplete circuits found</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = incompleteCircuits.map(circuit => `
            <div class="circuit-item incomplete">
                <h5>${circuit.name || 'Circuit'} <span class="badge bg-warning">Incomplete</span></h5>
                <div class="circuit-meta">
                    <span>Components: ${circuit.components.length}</span>
                    <span>CDS: ${circuit.component_counts?.cds || 0}</span>
                    <span>Missing Parts: ${Object.keys(circuit.fallback_by_cds).length}</span>
                </div>
                <div class="fallback-details">
                    <h6>Missing Components by CDS:</h6>
                    ${Object.entries(circuit.fallback_by_cds).map(([cds, fallbacks]) => `
                        <div class="fallback-item">
                            <strong>${cds}:</strong>
                            ${Object.entries(fallbacks).filter(([key, val]) => key.startsWith('missing_') && val).map(([key, val]) => {
                                const part = key.replace('missing_', '');
                                return `<span class="missing-part">${part}</span>`;
                            }).join(', ')}
                            ${(() => {
                                const showAdjusted = document.getElementById('enable_dial_params')?.checked;
                                if (!showAdjusted) return '';
                                return `${fallbacks.prom_strength !== undefined ? 
                                    `<small class="text-muted">(promoter strength adjusted to ${fallbacks.prom_strength})</small>` : ''}
                                ${fallbacks.rbs_efficiency !== undefined ? 
                                    `<small class="text-muted">(RBS efficiency adjusted to ${fallbacks.rbs_efficiency})</small>` : ''}
                                ${fallbacks.degradation_rate !== undefined ? 
                                    `<small class="text-muted">(degradation adjusted to ${fallbacks.degradation_rate})</small>` : ''}`;
                            })()}
                        </div>
                    `).join('')}
                </div>
            </div>
        `).join('');
    }
    
    function populateUnpairedRegulators(unpaired) {
        const container = document.getElementById('unpaired-regulators-list');
        
        if (!unpaired || unpaired.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-link text-muted"></i>
                    <p>All regulators are properly paired</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = unpaired.map(reg => `
            <div class="regulator-item unpaired">
                <h5>${reg.label} <span class="badge bg-danger">Unpaired</span></h5>
                <div class="regulator-issue">
                    <strong>Issue:</strong> ${reg.issue}
                </div>
                <div class="regulator-hint">
                    <strong>Solution:</strong> ${reg.hint}
                </div>
            </div>
        `).join('');
    }
    
    function populateValidCircuits(circuits) {
        const container = document.getElementById('valid-circuits-list');
        
        // Filter for complete circuits (no fallbacks)
        const completeCircuits = circuits.filter(circuit => !circuit.fallback_by_cds || Object.keys(circuit.fallback_by_cds).length === 0);
        
        if (completeCircuits.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-dna text-muted"></i>
                    <p>No complete circuits detected yet</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = completeCircuits.map(circuit => `
            <div class="circuit-item">
                <h5>${circuit.name || 'Circuit'}</h5>
                <div class="circuit-meta">
                    <span>Components: ${circuit.components.length}</span>
                    <span>CDS: ${circuit.component_counts?.cds || 0}</span>
                    <span>Promoters: ${circuit.component_counts?.promoter || 0}</span>
                </div>
                <div class="circuit-description">
                    ${generateCircuitDescription(circuit)}
                </div>
                <div class="component-badges">
                    ${circuit.components.map(comp => 
                        `<span class="component-badge ${comp.type}">${comp.type}</span>`
                    ).join('')}
                </div>
            </div>
        `).join('');
    }
    
    function populateRegulatoryNetworks(regulations) {
        const container = document.getElementById('regulations-list');
        
        if (regulations.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-project-diagram text-muted"></i>
                    <p>No regulatory networks found</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = regulations.map(reg => `
            <div class="regulation-item">
                <h5>${reg.type.toUpperCase()} Regulation</h5>
                <div class="regulation-meta">
                    <span>Source: ${reg.source || 'Constitutive'}</span>
                    <span>Target: ${reg.target}</span>
                </div>
                <div class="regulation-description">
                    ${generateRegulationDescription(reg)}
                </div>
            </div>
        `).join('');
    }
    
    function populateCircuitIssues(warnings, errors) {
        const container = document.getElementById('circuit-issues');
        const issues = [...warnings.map(w => ({type: 'warning', message: w})), 
                       ...errors.map(e => ({type: 'error', message: e}))];
        
        if (issues.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-shield-alt text-muted"></i>
                    <p>No issues detected</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = issues.map(issue => `
            <div class="issue-item">
                <h5>
                    <span class="issue-severity ${issue.type}">${issue.type.toUpperCase()}</span>
                    Circuit Issue
                </h5>
                <div class="issue-description">
                    ${issue.message}
                </div>
            </div>
        `).join('');
    }
    
    function populateExtraComponents(circuits) {
        const container = document.getElementById('extra-components-list');
        const allExtras = circuits.reduce((acc, c) => [...acc, ...(c.extras || [])], []);
        
        if (allExtras.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-puzzle-piece text-muted"></i>
                    <p>All components are properly assigned</p>
                </div>
            `;
            return;
        }
        
        container.innerHTML = allExtras.map(extra => `
            <div class="extra-item">
                <h5>Extra ${extra.type.toUpperCase()}</h5>
                <div class="extra-meta">
                    <span>Name: ${extra.name}</span>
                    <span>ID: ${extra.id}</span>
                </div>
                <div class="extra-description">
                    <strong>Reason:</strong> ${extra.reason || 'Component exceeds expected count'}
                </div>
            </div>
        `).join('');
    }
    
    function populateComponentAnalysis(circuits) {
        const container = document.getElementById('component-analysis');
        
        if (circuits.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-cube text-muted"></i>
                    <p>Place components to see detailed analysis</p>
                </div>
            `;
            return;
        }
        
        const componentStats = calculateComponentStats(circuits);
        
        container.innerHTML = `
            <div class="row">
                ${Object.entries(componentStats).map(([type, stats]) => `
                    <div class="col-md-6 mb-3">
                        <div class="component-item">
                            <h5>${capitalizeComponentType(type)} Components</h5>
                            <div class="component-meta">
                                <span>Count: ${stats.count}</span>
                                <span>Average Strength: ${stats.avgStrength}</span>
                            </div>
                            <div class="component-description">
                                ${generateComponentStatsDescription(type, stats)}
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    function generateCircuitDescription(circuit) {
        const compCounts = circuit.component_counts || {};
        const hasRegulators = (compCounts.repressor || 0) + (compCounts.activator || 0) > 0;
        
        if (compCounts.cds > 0 && compCounts.promoter > 0) {
            return `Complete functional circuit with ${compCounts.cds} CDS protein(s) under ${compCounts.promoter} Promoter(s)${hasRegulators ? ' with regulatory control' : ''}.`;
        } else {
            return 'Incomplete circuit missing essential components for protein expression.';
        }
    }
    
    function generateRegulationDescription(reg) {
        if (reg.type === 'constitutive') {
            return `Constitutive expression with basal rate of ${reg.parameters?.basal_rate || 'default'}.`;
        } else {
            return `${reg.type.charAt(0).toUpperCase() + reg.type.slice(1)} regulation affecting ${reg.affected_cdss?.length || 0} protein(s).`;
        }
    }
    
    function capitalizeComponentType(type) {
        const capitalizations = {
            'promoter': 'Promoter',
            'rbs': 'RBS', 
            'cds': 'CDS',
            'terminator': 'Terminator',
            'regulator': 'Regulator',
            'activator': 'Activator',
            'repressor': 'Repressor',
            'operator': 'Operator'
        };
        return capitalizations[type.toLowerCase()] || type.charAt(0).toUpperCase() + type.slice(1).toLowerCase();
    }
    
    function generateComponentStatsDescription(type, stats) {
        const descriptions = {
            'promoter': `Initiating gene expression with average strength ${stats.avgStrength}`,
            'rbs': `Translation efficiency averaging ${stats.avgStrength} strength`,
            'cds': `Protein coding sequences with ${stats.avgStrength} expression level`,
            'terminator': `Transcription termination with ${stats.avgStrength} efficiency`,
            'regulator': `Regulatory elements for circuit control`
        };
        return descriptions[type.toLowerCase()] || `${capitalizeComponentType(type)} components in the circuit`;
    }
    
    function calculateComponentStats(circuits) {
        const stats = {};
        
        circuits.forEach(circuit => {
            circuit.components.forEach(comp => {
                if (!stats[comp.type]) {
                    stats[comp.type] = { count: 0, totalStrength: 0, strengths: [] };
                }
                
                stats[comp.type].count++;
                
                // Try to extract strength from component parameters
                const strength = comp.parameters?.strength || 1;
                stats[comp.type].totalStrength += strength;
                stats[comp.type].strengths.push(strength);
            });
        });
        
        // Calculate averages
        Object.keys(stats).forEach(type => {
            const typeStats = stats[type];
            typeStats.avgStrength = (typeStats.totalStrength / typeStats.count).toFixed(2);
        });
        
        return stats;
    }

    function populateEquationDisplay(result) {
        const container = document.getElementById('equation-display-list');
        if (!container) return;
        
        const equations = result.equations || {};
        const proteinMapping = result.protein_mapping || {};
        
        if (Object.keys(equations).length === 0) {
            container.innerHTML = '<div class="alert alert-info"><i class="fas fa-info-circle me-2"></i>No protein equations generated</div>';
            return;
        }
        
        let html = '';
        
        // Add MathJax configuration if not already loaded
        if (typeof MathJax === 'undefined') {
            html += `
                <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
                <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
                <script>
                window.MathJax = {
                    tex: {
                        inlineMath: [['$', '$'], ['\\\\(', '\\\\)']],
                        displayMath: [['$$', '$$'], ['\\\\[', '\\\\]']]
                    }
                };
                </script>
            `;
        }
        
        Object.entries(equations).forEach(([protein, eq]) => {
            html += `
                <div class="card mb-3">
                    <div class="card-header">
                        <h6 class="mb-0">
                            <i class="fas fa-dna me-2"></i>
                            ${protein} Expression
                        </h6>
                    </div>
                    <div class="card-body">
                        <div class="equation-latex mb-3">
                            $$${eq.latex}$$
                        </div>
                        <div class="equation-description">
                            <p class="text-muted mb-2">
                                <strong>Description:</strong> ${eq.description}
                            </p>
                            <div class="equation-components">
                                <strong>Components:</strong>
                                <ul class="mb-0">
                                    ${eq.components.map(comp => `<li class="small">${comp}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        
        // Render MathJax if available
        if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
            MathJax.typesetPromise([container]).catch((err) => console.log('MathJax error:', err));
        }
    }

    // Export project functionality
    function exportProject() {
        // Show loading state
        const exportBtn = document.getElementById('export-btn');
        const originalText = exportBtn.innerHTML;
        exportBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Exporting...';
        exportBtn.disabled = true;

        // Create a temporary link to trigger download
        const link = document.createElement('a');
        link.href = '/export';
        link.download = ''; // Let the server determine the filename
        
        // Append to body, click, and remove
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // Reset button after a short delay
        setTimeout(() => {
            exportBtn.innerHTML = originalText;
            exportBtn.disabled = false;
        }, 2000);
    }

    // Expose state for debugging
    window.circuitDesigner = {
        state: state,
        placeComponent: placeComponent,
        removeComponent: removeComponent,
        clearBoard: clearBoard,
        runSimulation: runSimulation,
        populateOntologyAnalysis: populateOntologyAnalysis,
        exportProject: exportProject
    };
});
*/
